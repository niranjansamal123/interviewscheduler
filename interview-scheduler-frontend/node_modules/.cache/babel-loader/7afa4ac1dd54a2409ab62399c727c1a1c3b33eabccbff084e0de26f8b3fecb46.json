{"ast":null,"code":"const {\n  getPool,\n  sql\n} = require('../config/database');\nconst excelService = require('../services/excelService');\nconst emailService = require('../services/emailService');\nconst fs = require('fs');\nconst path = require('path');\nconst studentController = {\n  // ➤ Add single student - NO RESUME FIELD\n  addStudent: async (req, res) => {\n    try {\n      const {\n        name,\n        email,\n        phone\n      } = req.body; // Removed resumeLink\n      const pool = await getPool();\n\n      // Validate required fields\n      if (!name || !email || !phone) {\n        return res.status(400).json({\n          error: 'Name, email, and phone are required'\n        });\n      }\n\n      // Check duplicate email\n      const checkResult = await pool.request().input('email', sql.NVarChar, email.trim().toLowerCase()).query('SELECT Id FROM Students WHERE Email = @email');\n      if (checkResult.recordset.length > 0) {\n        return res.status(400).json({\n          error: 'Email already exists'\n        });\n      }\n      const result = await pool.request().input('name', sql.NVarChar, name.trim()).input('email', sql.NVarChar, email.trim().toLowerCase()).input('phone', sql.NVarChar, phone.trim()).query(`\n          INSERT INTO Students (Name, Email, Phone, CreatedAt)\n          VALUES (@name, @email, @phone, GETDATE());\n          SELECT SCOPE_IDENTITY() as Id;\n        `);\n      console.log('✅ Student added:', name, email);\n      res.status(201).json({\n        message: 'Student added successfully',\n        studentId: result.recordset[0].Id,\n        student: {\n          id: result.recordset[0].Id,\n          name: name.trim(),\n          email: email.trim().toLowerCase(),\n          phone: phone.trim()\n        }\n      });\n    } catch (error) {\n      console.error('❌ Error adding student:', error.message, error.stack);\n      res.status(500).json({\n        error: 'Failed to add student'\n      });\n    }\n  },\n  // ➤ Get all students\n  getStudents: async (req, res) => {\n    try {\n      const pool = await getPool();\n      const result = await pool.request().query('SELECT * FROM Students ORDER BY CreatedAt DESC');\n      res.json(result.recordset);\n    } catch (error) {\n      console.error('❌ Error fetching students:', error.message, error.stack);\n      res.status(500).json({\n        error: 'Failed to fetch students'\n      });\n    }\n  },\n  // ➤ Get student by token - WITH EXPIRATION CHECK\n  getStudentByToken: async (req, res) => {\n    try {\n      const {\n        token\n      } = req.params;\n      console.log('🔍 Getting student by token:', token ? `${token.substring(0, 10)}...` : 'missing');\n      if (!token) {\n        return res.status(400).json({\n          error: 'Token is required'\n        });\n      }\n      const pool = await getPool();\n      const result = await pool.request().input('token', sql.NVarChar, token).query(`\n          SELECT \n            s.Id, s.Name, s.Email, s.Phone, s.ResumeLink, s.ResumeFileName, s.CreatedAt,\n            i.Status as InterviewStatus,\n            i.TokenExpiredAt,\n            i.SlotId as ExistingSlotId,\n            i.MeetingLink,\n            i.Interviewer\n          FROM Students s\n          JOIN Interviews i ON s.Id = i.StudentId\n          WHERE i.InvitationToken = @token\n        `);\n      console.log('📊 Query result:', result.recordset.length, 'students found');\n      if (result.recordset.length === 0) {\n        return res.status(404).json({\n          error: 'Invalid invitation token'\n        });\n      }\n      const student = result.recordset[0];\n\n      // Check if token is expired\n      if (student.TokenExpiredAt) {\n        console.log('❌ Token expired at:', student.TokenExpiredAt);\n        return res.status(410).json({\n          error: 'This invitation link has expired and is no longer valid',\n          expiredAt: student.TokenExpiredAt,\n          reason: 'Link was used to book an interview slot',\n          studentName: student.Name\n        });\n      }\n\n      // Check if already scheduled (additional safety check)\n      if (student.ExistingSlotId) {\n        console.log('❌ Student already has slot booked:', student.ExistingSlotId);\n        return res.status(410).json({\n          error: 'You have already booked an interview slot with this invitation',\n          reason: 'Interview already scheduled',\n          slotId: student.ExistingSlotId,\n          meetingLink: student.MeetingLink,\n          interviewer: student.Interviewer\n        });\n      }\n\n      // Check interview status\n      if (student.InterviewStatus !== 'Invited') {\n        console.log('❌ Invalid interview status:', student.InterviewStatus);\n        return res.status(400).json({\n          error: `Interview status is ${student.InterviewStatus}. Cannot proceed with slot selection.`\n        });\n      }\n      res.json({\n        id: student.Id,\n        name: student.Name,\n        email: student.Email,\n        phone: student.Phone,\n        resumeLink: student.ResumeLink ? 'uploaded' : null,\n        // Just indicate if uploaded\n        createdAt: student.CreatedAt,\n        interviewStatus: student.InterviewStatus\n      });\n    } catch (error) {\n      console.error('❌ Error fetching student by token:', error.message, error.stack);\n      res.status(500).json({\n        error: 'Failed to fetch student'\n      });\n    }\n  },\n  // ➤ Update resume by token - STORE FILE PATH\n  updateResume: async (req, res) => {\n    try {\n      const {\n        token\n      } = req.params;\n      console.log('📄 Updating resume for token:', token ? `${token.substring(0, 10)}...` : 'missing');\n      if (!token) {\n        return res.status(400).json({\n          error: 'Token is required'\n        });\n      }\n      if (!req.file) {\n        return res.status(400).json({\n          error: 'No file uploaded'\n        });\n      }\n      const pool = await getPool();\n\n      // Check token validity and expiration\n      const tokenCheck = await pool.request().input('token', sql.NVarChar, token).query(`\n          SELECT \n            s.Id, s.Name, s.Email, \n            i.TokenExpiredAt, \n            i.Status as InterviewStatus,\n            i.SlotId as ExistingSlotId\n          FROM Students s\n          JOIN Interviews i ON s.Id = i.StudentId\n          WHERE i.InvitationToken = @token\n        `);\n      if (tokenCheck.recordset.length === 0) {\n        return res.status(404).json({\n          error: 'Invalid invitation token'\n        });\n      }\n      const student = tokenCheck.recordset[0];\n\n      // Check if token is expired\n      if (student.TokenExpiredAt) {\n        console.log('❌ Token expired, cannot update resume:', student.TokenExpiredAt);\n        return res.status(410).json({\n          error: 'This invitation link has expired and cannot be used to update resume',\n          expiredAt: student.TokenExpiredAt,\n          reason: 'Link was already used to book an interview slot'\n        });\n      }\n\n      // Check if already has a slot booked\n      if (student.ExistingSlotId) {\n        console.log('❌ Student already scheduled, cannot update resume:', student.ExistingSlotId);\n        return res.status(410).json({\n          error: 'You have already completed the interview booking process',\n          reason: 'Resume cannot be updated after slot booking'\n        });\n      }\n\n      // Check interview status\n      if (student.InterviewStatus !== 'Invited') {\n        return res.status(400).json({\n          error: `Interview status is ${student.InterviewStatus}. Cannot update resume.`\n        });\n      }\n\n      // Store the file path (not URL) and original filename\n      const filePath = req.file.path;\n      const originalFilename = req.file.originalname;\n\n      // Update the student's resume with file path and filename\n      const updateResult = await pool.request().input('token', sql.NVarChar, token).input('resumeLink', sql.NVarChar, filePath) // Store file path\n      .input('resumeFileName', sql.NVarChar, originalFilename).query(`\n          UPDATE Students \n          SET ResumeLink = @resumeLink, ResumeFileName = @resumeFileName\n          WHERE Id IN (\n            SELECT StudentId FROM Interviews \n            WHERE InvitationToken = @token \n            AND TokenExpiredAt IS NULL \n            AND Status = 'Invited'\n          )\n        `);\n\n      // Check if update was successful\n      if (updateResult.rowsAffected[0] === 0) {\n        return res.status(410).json({\n          error: 'Cannot update resume. The invitation may have expired or been used.',\n          reason: 'Token no longer valid for updates'\n        });\n      }\n      console.log(`✅ Resume updated for student: ${student.Name} (${student.Email})`);\n      res.json({\n        message: 'Resume updated successfully',\n        fileName: req.file.filename,\n        originalFileName: originalFilename,\n        studentName: student.Name\n      });\n    } catch (error) {\n      console.error('❌ Error updating resume:', error.message, error.stack);\n      res.status(500).json({\n        error: 'Failed to update resume'\n      });\n    }\n  },\n  // ➤ Download resume by student ID - ENHANCED WITH STUDENT NAME\n  downloadResume: async (req, res) => {\n    try {\n      const {\n        studentId\n      } = req.params;\n      console.log('📄 Resume download request for student:', studentId);\n      if (!studentId) {\n        return res.status(400).json({\n          error: 'Student ID is required'\n        });\n      }\n      const pool = await getPool();\n\n      // Get student and resume info\n      const result = await pool.request().input('studentId', sql.Int, parseInt(studentId)).query(`\n          SELECT Id, Name, Email, ResumeLink, ResumeFileName \n          FROM Students \n          WHERE Id = @studentId AND ResumeLink IS NOT NULL\n        `);\n      if (result.recordset.length === 0) {\n        return res.status(404).json({\n          error: 'Student not found or no resume uploaded'\n        });\n      }\n      const student = result.recordset[0];\n      let resumePath = student.ResumeLink;\n\n      // Handle different path formats\n      if (student.ResumeLink.startsWith('http')) {\n        // If it's a full URL, extract the filename\n        const urlParts = student.ResumeLink.split('/');\n        const filename = urlParts[urlParts.length - 1];\n        resumePath = path.join(__dirname, '../uploads', filename);\n      } else if (!path.isAbsolute(student.ResumeLink)) {\n        // If it's a relative path, make it absolute\n        resumePath = path.join(__dirname, '..', student.ResumeLink);\n      }\n\n      // Check if file exists\n      if (!fs.existsSync(resumePath)) {\n        console.error('❌ Resume file not found:', resumePath);\n        return res.status(404).json({\n          error: 'Resume file not found on server'\n        });\n      }\n\n      // Get file stats and extension\n      const stats = fs.statSync(resumePath);\n      const fileExtension = path.extname(resumePath).toLowerCase();\n\n      // Set appropriate content type\n      let contentType = 'application/octet-stream';\n      switch (fileExtension) {\n        case '.pdf':\n          contentType = 'application/pdf';\n          break;\n        case '.doc':\n          contentType = 'application/msword';\n          break;\n        case '.docx':\n          contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n          break;\n      }\n\n      // Generate clean student name for filename\n      const cleanStudentName = student.Name.trim().replace(/[^a-zA-Z0-9\\s]/g, '') // Remove special characters\n      .replace(/\\s+/g, '_') // Replace spaces with underscores\n      .substring(0, 50); // Limit length to 50 characters\n\n      // Create filename with student name and timestamp\n      const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format\n      const downloadFilename = `${cleanStudentName}_Resume_${timestamp}${fileExtension}`;\n\n      // Set headers for download\n      res.setHeader('Content-Type', contentType);\n      res.setHeader('Content-Length', stats.size);\n      res.setHeader('Content-Disposition', `attachment; filename=\"${downloadFilename}\"`);\n      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\n      res.setHeader('Pragma', 'no-cache');\n      res.setHeader('Expires', '0');\n      console.log(`📥 Serving resume download: ${downloadFilename} (${stats.size} bytes) for ${student.Name}`);\n\n      // Stream the file\n      const fileStream = fs.createReadStream(resumePath);\n      fileStream.pipe(res);\n      fileStream.on('error', error => {\n        console.error('❌ Error streaming file:', error);\n        if (!res.headersSent) {\n          res.status(500).json({\n            error: 'Failed to download resume'\n          });\n        }\n      });\n      fileStream.on('end', () => {\n        console.log('✅ Resume download completed for:', student.Name);\n      });\n    } catch (error) {\n      console.error('❌ Error downloading resume:', error);\n      if (!res.headersSent) {\n        res.status(500).json({\n          error: 'Failed to download resume'\n        });\n      }\n    }\n  },\n  // ➤ NEW: Bulk download resumes by student IDs\n  downloadBulkResumes: async (req, res) => {\n    try {\n      const {\n        studentIds\n      } = req.body;\n      if (!Array.isArray(studentIds) || studentIds.length === 0) {\n        return res.status(400).json({\n          error: 'Student IDs array is required'\n        });\n      }\n      console.log('📦 Bulk resume download request for', studentIds.length, 'students');\n      const pool = await getPool();\n      const request = pool.request();\n\n      // Build parameterized query inputs\n      studentIds.forEach((id, index) => {\n        request.input(`id${index}`, sql.Int, parseInt(id));\n      });\n      const query = `\n        SELECT Id, Name, Email, ResumeLink, ResumeFileName \n        FROM Students\n        WHERE Id IN (${studentIds.map((_, i) => `@id${i}`).join(',')})\n        AND ResumeLink IS NOT NULL\n      `;\n      const result = await request.query(query);\n      if (result.recordset.length === 0) {\n        return res.status(404).json({\n          error: 'No students with resumes found'\n        });\n      }\n\n      // Create a zip file for bulk download\n      const archiver = require('archiver');\n      const archive = archiver('zip', {\n        zlib: {\n          level: 9\n        }\n      });\n      const timestamp = new Date().toISOString().split('T')[0];\n      const zipFilename = `Student_Resumes_${timestamp}.zip`;\n      res.setHeader('Content-Type', 'application/zip');\n      res.setHeader('Content-Disposition', `attachment; filename=\"${zipFilename}\"`);\n      archive.pipe(res);\n      let filesAdded = 0;\n      let filesSkipped = 0;\n      for (const student of result.recordset) {\n        try {\n          let resumePath = student.ResumeLink;\n\n          // Handle different path formats\n          if (student.ResumeLink.startsWith('http')) {\n            const urlParts = student.ResumeLink.split('/');\n            const filename = urlParts[urlParts.length - 1];\n            resumePath = path.join(__dirname, '../uploads', filename);\n          } else if (!path.isAbsolute(student.ResumeLink)) {\n            resumePath = path.join(__dirname, '..', student.ResumeLink);\n          }\n\n          // Check if file exists\n          if (fs.existsSync(resumePath)) {\n            const fileExtension = path.extname(resumePath).toLowerCase();\n            const cleanStudentName = student.Name.trim().replace(/[^a-zA-Z0-9\\s]/g, '').replace(/\\s+/g, '_').substring(0, 50);\n            const archiveFilename = `${cleanStudentName}_Resume${fileExtension}`;\n            archive.file(resumePath, {\n              name: archiveFilename\n            });\n            filesAdded++;\n            console.log(`📄 Added to archive: ${archiveFilename}`);\n          } else {\n            console.warn(`⚠️ Resume file not found for ${student.Name}: ${resumePath}`);\n            filesSkipped++;\n          }\n        } catch (fileError) {\n          console.error(`❌ Error processing resume for ${student.Name}:`, fileError.message);\n          filesSkipped++;\n        }\n      }\n      archive.finalize();\n      archive.on('end', () => {\n        console.log(`✅ Bulk download completed: ${filesAdded} files added, ${filesSkipped} files skipped`);\n      });\n      archive.on('error', error => {\n        console.error('❌ Error creating zip archive:', error);\n        if (!res.headersSent) {\n          res.status(500).json({\n            error: 'Failed to create resume archive'\n          });\n        }\n      });\n    } catch (error) {\n      console.error('❌ Error in bulk download:', error);\n      if (!res.headersSent) {\n        res.status(500).json({\n          error: 'Failed to process bulk download'\n        });\n      }\n    }\n  },\n  // ➤ Upload Excel file & process\n  uploadExcel: async (req, res) => {\n    try {\n      if (!req.file) {\n        return res.status(400).json({\n          error: 'No file uploaded'\n        });\n      }\n      const filePath = req.file.path;\n      const result = await excelService.processExcelFile(filePath);\n      res.json({\n        message: 'Excel file processed successfully',\n        summary: result\n      });\n    } catch (error) {\n      console.error('❌ Error processing Excel file:', error.message, error.stack);\n      res.status(500).json({\n        error: 'Failed to process Excel file'\n      });\n    }\n  },\n  // ➤ Download sample Excel template\n  downloadSampleExcel: async (req, res) => {\n    try {\n      const buffer = excelService.generateSampleExcel();\n      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n      res.setHeader('Content-Disposition', 'attachment; filename=\"student-template.xlsx\"');\n      res.send(buffer);\n    } catch (error) {\n      console.error('❌ Error generating sample:', error);\n      res.status(500).json({\n        error: 'Failed to generate sample template'\n      });\n    }\n  },\n  // ➤ Send invitation emails\n  sendInvitations: async (req, res) => {\n    try {\n      const {\n        studentIds\n      } = req.body;\n      if (!Array.isArray(studentIds) || studentIds.length === 0) {\n        return res.status(400).json({\n          error: 'No student IDs provided'\n        });\n      }\n      const pool = await getPool();\n      const request = pool.request();\n\n      // Build parameterized query inputs\n      studentIds.forEach((id, index) => {\n        request.input(`id${index}`, sql.Int, id);\n      });\n      const query = `\n        SELECT * FROM Students\n        WHERE Id IN (${studentIds.map((_, i) => `@id${i}`).join(',')})\n      `;\n      const students = await request.query(query);\n      if (students.recordset.length === 0) {\n        return res.status(404).json({\n          error: 'No students found for given IDs'\n        });\n      }\n      console.log(\"📩 Sending invitations to:\", students.recordset.length, \"students\");\n\n      // Send all invitations in parallel with error handling\n      const invitationPromises = students.recordset.map(async student => {\n        try {\n          const result = await emailService.sendInvitationEmail(student);\n          return {\n            success: true,\n            student: {\n              id: student.Id,\n              name: student.Name,\n              email: student.Email\n            },\n            ...result\n          };\n        } catch (err) {\n          console.error(`❌ Failed to send email to ${student.Email}:`, err.message);\n          return {\n            success: false,\n            error: err.message,\n            student: {\n              id: student.Id,\n              name: student.Name,\n              email: student.Email\n            }\n          };\n        }\n      });\n      const results = await Promise.all(invitationPromises);\n\n      // Count success/failure\n      const successful = results.filter(r => r.success).length;\n      const failed = results.filter(r => !r.success).length;\n      console.log(`📊 Invitation results: ${successful} successful, ${failed} failed`);\n      res.json({\n        message: 'Invitation process completed',\n        summary: {\n          total: results.length,\n          successful,\n          failed\n        },\n        results\n      });\n    } catch (error) {\n      console.error('🔥 Error in sendInvitations:', error);\n      res.status(500).json({\n        error: 'Failed to send invitations',\n        details: error.message\n      });\n    }\n  },\n  // ➤ Delete student by ID\n  deleteStudent: async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      if (isNaN(id)) {\n        return res.status(400).json({\n          error: 'Invalid student ID'\n        });\n      }\n      const pool = await getPool();\n\n      // Get student info before deletion (for file cleanup)\n      const studentInfo = await pool.request().input('id', sql.Int, id).query('SELECT Name, ResumeLink FROM Students WHERE Id = @id');\n\n      // Check if student is referenced by Interviews or other tables\n      const refCheck = await pool.request().input('id', sql.Int, id).query(`\n          SELECT COUNT(*) AS count,\n          (SELECT TOP 1 Status FROM Interviews WHERE StudentId = @id) AS InterviewStatus\n          FROM Interviews WHERE StudentId = @id\n        `);\n      if (refCheck.recordset[0].count > 0) {\n        const interviewStatus = refCheck.recordset[0].InterviewStatus;\n        const errorMessage = `Cannot delete student with ${interviewStatus.toLowerCase()} interview`;\n        console.error(`Delete blocked: ${errorMessage} for student ID ${id}`);\n        return res.status(400).json({\n          error: errorMessage,\n          interviewStatus: interviewStatus\n        });\n      }\n\n      // Proceed to delete student\n      const deleteResult = await pool.request().input('id', sql.Int, id).query('DELETE FROM Students WHERE Id = @id');\n      if (deleteResult.rowsAffected[0] === 0) {\n        return res.status(404).json({\n          error: 'Student not found'\n        });\n      }\n\n      // Clean up resume file if exists\n      if (studentInfo.recordset.length > 0 && studentInfo.recordset[0].ResumeLink) {\n        try {\n          const resumePath = studentInfo.recordset[0].ResumeLink;\n          let actualPath = resumePath;\n          if (!path.isAbsolute(resumePath)) {\n            actualPath = path.join(__dirname, '..', resumePath);\n          }\n          if (fs.existsSync(actualPath)) {\n            fs.unlinkSync(actualPath);\n            console.log('🗑️ Resume file deleted:', actualPath);\n          }\n        } catch (fileError) {\n          console.warn('⚠️ Could not delete resume file:', fileError.message);\n        }\n      }\n      console.log('🗑️ Student deleted:', id);\n      res.json({\n        message: 'Student deleted successfully'\n      });\n    } catch (error) {\n      console.error('❌ Error deleting student:', error.message || error);\n      res.status(500).json({\n        error: error.message || 'Failed to delete student'\n      });\n    }\n  },\n  // ➤ Bulk delete students by date range\n  bulkDeleteByDate: async (req, res) => {\n    try {\n      const {\n        start,\n        end\n      } = req.query;\n      if (!start || !end) {\n        return res.status(400).json({\n          error: 'Missing start or end date'\n        });\n      }\n      const pool = await getPool();\n\n      // First check how many students would be affected\n      const checkResult = await pool.request().input('start', sql.DateTime2, new Date(start)).input('end', sql.DateTime2, new Date(end)).query(`\n          SELECT COUNT(*) as TotalCount,\n          COUNT(i.Id) as WithInterviews\n          FROM Students s\n          LEFT JOIN Interviews i ON s.Id = i.StudentId\n          WHERE s.CreatedAt BETWEEN @start AND @end\n        `);\n      const {\n        TotalCount,\n        WithInterviews\n      } = checkResult.recordset[0];\n      if (WithInterviews > 0) {\n        return res.status(400).json({\n          error: `Cannot delete students with interviews. ${WithInterviews} out of ${TotalCount} students have interview records.`,\n          studentsWithInterviews: WithInterviews,\n          totalStudents: TotalCount\n        });\n      }\n\n      // Get resume files to clean up\n      const resumeFiles = await pool.request().input('start', sql.DateTime2, new Date(start)).input('end', sql.DateTime2, new Date(end)).query(`\n          SELECT ResumeLink FROM Students \n          WHERE CreatedAt BETWEEN @start AND @end \n          AND ResumeLink IS NOT NULL\n          AND Id NOT IN (SELECT DISTINCT StudentId FROM Interviews WHERE StudentId IS NOT NULL)\n        `);\n\n      // Proceed with deletion if no interviews found\n      const result = await pool.request().input('start', sql.DateTime2, new Date(start)).input('end', sql.DateTime2, new Date(end)).query(`\n          DELETE FROM Students \n          WHERE CreatedAt BETWEEN @start AND @end\n          AND Id NOT IN (SELECT DISTINCT StudentId FROM Interviews WHERE StudentId IS NOT NULL)\n        `);\n\n      // Clean up resume files\n      let filesDeleted = 0;\n      for (const row of resumeFiles.recordset) {\n        try {\n          let resumePath = row.ResumeLink;\n          if (!path.isAbsolute(resumePath)) {\n            resumePath = path.join(__dirname, '..', resumePath);\n          }\n          if (fs.existsSync(resumePath)) {\n            fs.unlinkSync(resumePath);\n            filesDeleted++;\n          }\n        } catch (fileError) {\n          console.warn('⚠️ Could not delete resume file:', fileError.message);\n        }\n      }\n      console.log(`🗑️ Bulk deleted ${result.rowsAffected[0]} students and ${filesDeleted} resume files from ${start} to ${end}`);\n      res.json({\n        message: 'Students deleted successfully',\n        deletedCount: result.rowsAffected[0],\n        filesDeleted,\n        dateRange: {\n          start,\n          end\n        }\n      });\n    } catch (error) {\n      console.error('❌ Error in bulkDeleteByDate:', error);\n      res.status(500).json({\n        error: 'Failed to bulk delete students'\n      });\n    }\n  },\n  // ➤ Get student interview status (NEW - for admin)\n  getStudentInterviewStatus: async (req, res) => {\n    try {\n      const {\n        studentId\n      } = req.params;\n      if (!studentId) {\n        return res.status(400).json({\n          error: 'Student ID is required'\n        });\n      }\n      const pool = await getPool();\n      const result = await pool.request().input('studentId', sql.Int, parseInt(studentId)).query(`\n          SELECT \n            s.*,\n            i.Status as InterviewStatus,\n            i.InvitationToken,\n            i.TokenExpiredAt,\n            i.SlotId,\n            i.Interviewer,\n            i.MeetingLink,\n            i.CreatedAt as InvitationSentAt,\n            sl.SlotDateTime\n          FROM Students s\n          LEFT JOIN Interviews i ON s.Id = i.StudentId\n          LEFT JOIN InterviewSlots sl ON i.SlotId = sl.Id\n          WHERE s.Id = @studentId\n        `);\n      if (result.recordset.length === 0) {\n        return res.status(404).json({\n          error: 'Student not found'\n        });\n      }\n      const studentData = result.recordset[0];\n      res.json({\n        student: {\n          id: studentData.Id,\n          name: studentData.Name,\n          email: studentData.Email,\n          phone: studentData.Phone,\n          hasResume: !!studentData.ResumeLink,\n          resumeFileName: studentData.ResumeFileName\n        },\n        interview: {\n          status: studentData.InterviewStatus || 'Not Invited',\n          tokenExpired: !!studentData.TokenExpiredAt,\n          tokenExpiredAt: studentData.TokenExpiredAt,\n          slotId: studentData.SlotId,\n          slotDateTime: studentData.SlotDateTime,\n          interviewer: studentData.Interviewer,\n          meetingLink: studentData.MeetingLink,\n          invitationSentAt: studentData.InvitationSentAt\n        }\n      });\n    } catch (error) {\n      console.error('❌ Error fetching student status:', error);\n      res.status(500).json({\n        error: 'Failed to fetch student status'\n      });\n    }\n  }\n};\nmodule.exports = studentController;","map":{"version":3,"names":["getPool","sql","require","excelService","emailService","fs","path","studentController","addStudent","req","res","name","email","phone","body","pool","status","json","error","checkResult","request","input","NVarChar","trim","toLowerCase","query","recordset","length","result","console","log","message","studentId","Id","student","id","stack","getStudents","getStudentByToken","token","params","substring","TokenExpiredAt","expiredAt","reason","studentName","Name","ExistingSlotId","slotId","meetingLink","MeetingLink","interviewer","Interviewer","InterviewStatus","Email","Phone","resumeLink","ResumeLink","createdAt","CreatedAt","interviewStatus","updateResume","file","tokenCheck","filePath","originalFilename","originalname","updateResult","rowsAffected","fileName","filename","originalFileName","downloadResume","Int","parseInt","resumePath","startsWith","urlParts","split","join","__dirname","isAbsolute","existsSync","stats","statSync","fileExtension","extname","contentType","cleanStudentName","replace","timestamp","Date","toISOString","downloadFilename","setHeader","size","fileStream","createReadStream","pipe","on","headersSent","downloadBulkResumes","studentIds","Array","isArray","forEach","index","map","_","i","archiver","archive","zlib","level","zipFilename","filesAdded","filesSkipped","archiveFilename","warn","fileError","finalize","uploadExcel","processExcelFile","summary","downloadSampleExcel","buffer","generateSampleExcel","send","sendInvitations","students","invitationPromises","sendInvitationEmail","success","err","results","Promise","all","successful","filter","r","failed","total","details","deleteStudent","isNaN","studentInfo","refCheck","count","errorMessage","deleteResult","actualPath","unlinkSync","bulkDeleteByDate","start","end","DateTime2","TotalCount","WithInterviews","studentsWithInterviews","totalStudents","resumeFiles","filesDeleted","row","deletedCount","dateRange","getStudentInterviewStatus","studentData","hasResume","resumeFileName","ResumeFileName","interview","tokenExpired","tokenExpiredAt","SlotId","slotDateTime","SlotDateTime","invitationSentAt","InvitationSentAt","module","exports"],"sources":["E:/Downloads/interview-scheduler/interview-scheduler-frontend/src/services/studentService.js"],"sourcesContent":["const { getPool, sql } = require('../config/database');\r\nconst excelService = require('../services/excelService');\r\nconst emailService = require('../services/emailService');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconst studentController = {\r\n  // ➤ Add single student - NO RESUME FIELD\r\n  addStudent: async (req, res) => {\r\n    try {\r\n      const { name, email, phone } = req.body; // Removed resumeLink\r\n      const pool = await getPool();\r\n\r\n      // Validate required fields\r\n      if (!name || !email || !phone) {\r\n        return res.status(400).json({ error: 'Name, email, and phone are required' });\r\n      }\r\n\r\n      // Check duplicate email\r\n      const checkResult = await pool.request()\r\n        .input('email', sql.NVarChar, email.trim().toLowerCase())\r\n        .query('SELECT Id FROM Students WHERE Email = @email');\r\n\r\n      if (checkResult.recordset.length > 0) {\r\n        return res.status(400).json({ error: 'Email already exists' });\r\n      }\r\n\r\n      const result = await pool.request()\r\n        .input('name', sql.NVarChar, name.trim())\r\n        .input('email', sql.NVarChar, email.trim().toLowerCase())\r\n        .input('phone', sql.NVarChar, phone.trim())\r\n        .query(`\r\n          INSERT INTO Students (Name, Email, Phone, CreatedAt)\r\n          VALUES (@name, @email, @phone, GETDATE());\r\n          SELECT SCOPE_IDENTITY() as Id;\r\n        `);\r\n\r\n      console.log('✅ Student added:', name, email);\r\n      res.status(201).json({\r\n        message: 'Student added successfully',\r\n        studentId: result.recordset[0].Id,\r\n        student: {\r\n          id: result.recordset[0].Id,\r\n          name: name.trim(),\r\n          email: email.trim().toLowerCase(),\r\n          phone: phone.trim()\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error adding student:', error.message, error.stack);\r\n      res.status(500).json({ error: 'Failed to add student' });\r\n    }\r\n  },\r\n\r\n  // ➤ Get all students\r\n  getStudents: async (req, res) => {\r\n    try {\r\n      const pool = await getPool();\r\n      const result = await pool.request()\r\n        .query('SELECT * FROM Students ORDER BY CreatedAt DESC');\r\n\r\n      res.json(result.recordset);\r\n    } catch (error) {\r\n      console.error('❌ Error fetching students:', error.message, error.stack);\r\n      res.status(500).json({ error: 'Failed to fetch students' });\r\n    }\r\n  },\r\n\r\n  // ➤ Get student by token - WITH EXPIRATION CHECK\r\n  getStudentByToken: async (req, res) => {\r\n    try {\r\n      const { token } = req.params;\r\n      console.log('🔍 Getting student by token:', token ? `${token.substring(0, 10)}...` : 'missing');\r\n      \r\n      if (!token) {\r\n        return res.status(400).json({ error: 'Token is required' });\r\n      }\r\n\r\n      const pool = await getPool();\r\n      \r\n      const result = await pool.request()\r\n        .input('token', sql.NVarChar, token)\r\n        .query(`\r\n          SELECT \r\n            s.Id, s.Name, s.Email, s.Phone, s.ResumeLink, s.ResumeFileName, s.CreatedAt,\r\n            i.Status as InterviewStatus,\r\n            i.TokenExpiredAt,\r\n            i.SlotId as ExistingSlotId,\r\n            i.MeetingLink,\r\n            i.Interviewer\r\n          FROM Students s\r\n          JOIN Interviews i ON s.Id = i.StudentId\r\n          WHERE i.InvitationToken = @token\r\n        `);\r\n      \r\n      console.log('📊 Query result:', result.recordset.length, 'students found');\r\n      \r\n      if (result.recordset.length === 0) {\r\n        return res.status(404).json({ error: 'Invalid invitation token' });\r\n      }\r\n      \r\n      const student = result.recordset[0];\r\n\r\n      // Check if token is expired\r\n      if (student.TokenExpiredAt) {\r\n        console.log('❌ Token expired at:', student.TokenExpiredAt);\r\n        return res.status(410).json({ \r\n          error: 'This invitation link has expired and is no longer valid',\r\n          expiredAt: student.TokenExpiredAt,\r\n          reason: 'Link was used to book an interview slot',\r\n          studentName: student.Name\r\n        });\r\n      }\r\n\r\n      // Check if already scheduled (additional safety check)\r\n      if (student.ExistingSlotId) {\r\n        console.log('❌ Student already has slot booked:', student.ExistingSlotId);\r\n        return res.status(410).json({ \r\n          error: 'You have already booked an interview slot with this invitation',\r\n          reason: 'Interview already scheduled',\r\n          slotId: student.ExistingSlotId,\r\n          meetingLink: student.MeetingLink,\r\n          interviewer: student.Interviewer\r\n        });\r\n      }\r\n\r\n      // Check interview status\r\n      if (student.InterviewStatus !== 'Invited') {\r\n        console.log('❌ Invalid interview status:', student.InterviewStatus);\r\n        return res.status(400).json({ \r\n          error: `Interview status is ${student.InterviewStatus}. Cannot proceed with slot selection.`\r\n        });\r\n      }\r\n\r\n      res.json({\r\n        id: student.Id,\r\n        name: student.Name,\r\n        email: student.Email,\r\n        phone: student.Phone,\r\n        resumeLink: student.ResumeLink ? 'uploaded' : null, // Just indicate if uploaded\r\n        createdAt: student.CreatedAt,\r\n        interviewStatus: student.InterviewStatus\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error fetching student by token:', error.message, error.stack);\r\n      res.status(500).json({ error: 'Failed to fetch student' });\r\n    }\r\n  },\r\n\r\n  // ➤ Update resume by token - STORE FILE PATH\r\n  updateResume: async (req, res) => {\r\n    try {\r\n      const { token } = req.params;\r\n      console.log('📄 Updating resume for token:', token ? `${token.substring(0, 10)}...` : 'missing');\r\n      \r\n      if (!token) {\r\n        return res.status(400).json({ error: 'Token is required' });\r\n      }\r\n      \r\n      if (!req.file) {\r\n        return res.status(400).json({ error: 'No file uploaded' });\r\n      }\r\n\r\n      const pool = await getPool();\r\n      \r\n      // Check token validity and expiration\r\n      const tokenCheck = await pool.request()\r\n        .input('token', sql.NVarChar, token)\r\n        .query(`\r\n          SELECT \r\n            s.Id, s.Name, s.Email, \r\n            i.TokenExpiredAt, \r\n            i.Status as InterviewStatus,\r\n            i.SlotId as ExistingSlotId\r\n          FROM Students s\r\n          JOIN Interviews i ON s.Id = i.StudentId\r\n          WHERE i.InvitationToken = @token\r\n        `);\r\n      \r\n      if (tokenCheck.recordset.length === 0) {\r\n        return res.status(404).json({ error: 'Invalid invitation token' });\r\n      }\r\n\r\n      const student = tokenCheck.recordset[0];\r\n\r\n      // Check if token is expired\r\n      if (student.TokenExpiredAt) {\r\n        console.log('❌ Token expired, cannot update resume:', student.TokenExpiredAt);\r\n        return res.status(410).json({ \r\n          error: 'This invitation link has expired and cannot be used to update resume',\r\n          expiredAt: student.TokenExpiredAt,\r\n          reason: 'Link was already used to book an interview slot'\r\n        });\r\n      }\r\n\r\n      // Check if already has a slot booked\r\n      if (student.ExistingSlotId) {\r\n        console.log('❌ Student already scheduled, cannot update resume:', student.ExistingSlotId);\r\n        return res.status(410).json({ \r\n          error: 'You have already completed the interview booking process',\r\n          reason: 'Resume cannot be updated after slot booking'\r\n        });\r\n      }\r\n\r\n      // Check interview status\r\n      if (student.InterviewStatus !== 'Invited') {\r\n        return res.status(400).json({ \r\n          error: `Interview status is ${student.InterviewStatus}. Cannot update resume.`\r\n        });\r\n      }\r\n\r\n      // Store the file path (not URL) and original filename\r\n      const filePath = req.file.path;\r\n      const originalFilename = req.file.originalname;\r\n      \r\n      // Update the student's resume with file path and filename\r\n      const updateResult = await pool.request()\r\n        .input('token', sql.NVarChar, token)\r\n        .input('resumeLink', sql.NVarChar, filePath) // Store file path\r\n        .input('resumeFileName', sql.NVarChar, originalFilename)\r\n        .query(`\r\n          UPDATE Students \r\n          SET ResumeLink = @resumeLink, ResumeFileName = @resumeFileName\r\n          WHERE Id IN (\r\n            SELECT StudentId FROM Interviews \r\n            WHERE InvitationToken = @token \r\n            AND TokenExpiredAt IS NULL \r\n            AND Status = 'Invited'\r\n          )\r\n        `);\r\n\r\n      // Check if update was successful\r\n      if (updateResult.rowsAffected[0] === 0) {\r\n        return res.status(410).json({ \r\n          error: 'Cannot update resume. The invitation may have expired or been used.',\r\n          reason: 'Token no longer valid for updates'\r\n        });\r\n      }\r\n      \r\n      console.log(`✅ Resume updated for student: ${student.Name} (${student.Email})`);\r\n      \r\n      res.json({ \r\n        message: 'Resume updated successfully',\r\n        fileName: req.file.filename,\r\n        originalFileName: originalFilename,\r\n        studentName: student.Name\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error updating resume:', error.message, error.stack);\r\n      res.status(500).json({ error: 'Failed to update resume' });\r\n    }\r\n  },\r\n\r\n  // ➤ Download resume by student ID - ENHANCED WITH STUDENT NAME\r\n  downloadResume: async (req, res) => {\r\n    try {\r\n      const { studentId } = req.params;\r\n      console.log('📄 Resume download request for student:', studentId);\r\n      \r\n      if (!studentId) {\r\n        return res.status(400).json({ error: 'Student ID is required' });\r\n      }\r\n\r\n      const pool = await getPool();\r\n      \r\n      // Get student and resume info\r\n      const result = await pool.request()\r\n        .input('studentId', sql.Int, parseInt(studentId))\r\n        .query(`\r\n          SELECT Id, Name, Email, ResumeLink, ResumeFileName \r\n          FROM Students \r\n          WHERE Id = @studentId AND ResumeLink IS NOT NULL\r\n        `);\r\n      \r\n      if (result.recordset.length === 0) {\r\n        return res.status(404).json({ error: 'Student not found or no resume uploaded' });\r\n      }\r\n\r\n      const student = result.recordset[0];\r\n      let resumePath = student.ResumeLink;\r\n\r\n      // Handle different path formats\r\n      if (student.ResumeLink.startsWith('http')) {\r\n        // If it's a full URL, extract the filename\r\n        const urlParts = student.ResumeLink.split('/');\r\n        const filename = urlParts[urlParts.length - 1];\r\n        resumePath = path.join(__dirname, '../uploads', filename);\r\n      } else if (!path.isAbsolute(student.ResumeLink)) {\r\n        // If it's a relative path, make it absolute\r\n        resumePath = path.join(__dirname, '..', student.ResumeLink);\r\n      }\r\n\r\n      // Check if file exists\r\n      if (!fs.existsSync(resumePath)) {\r\n        console.error('❌ Resume file not found:', resumePath);\r\n        return res.status(404).json({ error: 'Resume file not found on server' });\r\n      }\r\n\r\n      // Get file stats and extension\r\n      const stats = fs.statSync(resumePath);\r\n      const fileExtension = path.extname(resumePath).toLowerCase();\r\n      \r\n      // Set appropriate content type\r\n      let contentType = 'application/octet-stream';\r\n      switch (fileExtension) {\r\n        case '.pdf':\r\n          contentType = 'application/pdf';\r\n          break;\r\n        case '.doc':\r\n          contentType = 'application/msword';\r\n          break;\r\n        case '.docx':\r\n          contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\r\n          break;\r\n      }\r\n\r\n      // Generate clean student name for filename\r\n      const cleanStudentName = student.Name\r\n        .trim()\r\n        .replace(/[^a-zA-Z0-9\\s]/g, '') // Remove special characters\r\n        .replace(/\\s+/g, '_') // Replace spaces with underscores\r\n        .substring(0, 50); // Limit length to 50 characters\r\n\r\n      // Create filename with student name and timestamp\r\n      const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format\r\n      const downloadFilename = `${cleanStudentName}_Resume_${timestamp}${fileExtension}`;\r\n\r\n      // Set headers for download\r\n      res.setHeader('Content-Type', contentType);\r\n      res.setHeader('Content-Length', stats.size);\r\n      res.setHeader('Content-Disposition', `attachment; filename=\"${downloadFilename}\"`);\r\n      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\r\n      res.setHeader('Pragma', 'no-cache');\r\n      res.setHeader('Expires', '0');\r\n\r\n      console.log(`📥 Serving resume download: ${downloadFilename} (${stats.size} bytes) for ${student.Name}`);\r\n\r\n      // Stream the file\r\n      const fileStream = fs.createReadStream(resumePath);\r\n      fileStream.pipe(res);\r\n      \r\n      fileStream.on('error', (error) => {\r\n        console.error('❌ Error streaming file:', error);\r\n        if (!res.headersSent) {\r\n          res.status(500).json({ error: 'Failed to download resume' });\r\n        }\r\n      });\r\n\r\n      fileStream.on('end', () => {\r\n        console.log('✅ Resume download completed for:', student.Name);\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error downloading resume:', error);\r\n      if (!res.headersSent) {\r\n        res.status(500).json({ error: 'Failed to download resume' });\r\n      }\r\n    }\r\n  },\r\n\r\n  // ➤ NEW: Bulk download resumes by student IDs\r\n  downloadBulkResumes: async (req, res) => {\r\n    try {\r\n      const { studentIds } = req.body;\r\n      \r\n      if (!Array.isArray(studentIds) || studentIds.length === 0) {\r\n        return res.status(400).json({ error: 'Student IDs array is required' });\r\n      }\r\n\r\n      console.log('📦 Bulk resume download request for', studentIds.length, 'students');\r\n\r\n      const pool = await getPool();\r\n      const request = pool.request();\r\n\r\n      // Build parameterized query inputs\r\n      studentIds.forEach((id, index) => {\r\n        request.input(`id${index}`, sql.Int, parseInt(id));\r\n      });\r\n\r\n      const query = `\r\n        SELECT Id, Name, Email, ResumeLink, ResumeFileName \r\n        FROM Students\r\n        WHERE Id IN (${studentIds.map((_, i) => `@id${i}`).join(',')})\r\n        AND ResumeLink IS NOT NULL\r\n      `;\r\n\r\n      const result = await request.query(query);\r\n\r\n      if (result.recordset.length === 0) {\r\n        return res.status(404).json({ error: 'No students with resumes found' });\r\n      }\r\n\r\n      // Create a zip file for bulk download\r\n      const archiver = require('archiver');\r\n      const archive = archiver('zip', { zlib: { level: 9 } });\r\n\r\n      const timestamp = new Date().toISOString().split('T')[0];\r\n      const zipFilename = `Student_Resumes_${timestamp}.zip`;\r\n\r\n      res.setHeader('Content-Type', 'application/zip');\r\n      res.setHeader('Content-Disposition', `attachment; filename=\"${zipFilename}\"`);\r\n\r\n      archive.pipe(res);\r\n\r\n      let filesAdded = 0;\r\n      let filesSkipped = 0;\r\n\r\n      for (const student of result.recordset) {\r\n        try {\r\n          let resumePath = student.ResumeLink;\r\n\r\n          // Handle different path formats\r\n          if (student.ResumeLink.startsWith('http')) {\r\n            const urlParts = student.ResumeLink.split('/');\r\n            const filename = urlParts[urlParts.length - 1];\r\n            resumePath = path.join(__dirname, '../uploads', filename);\r\n          } else if (!path.isAbsolute(student.ResumeLink)) {\r\n            resumePath = path.join(__dirname, '..', student.ResumeLink);\r\n          }\r\n\r\n          // Check if file exists\r\n          if (fs.existsSync(resumePath)) {\r\n            const fileExtension = path.extname(resumePath).toLowerCase();\r\n            const cleanStudentName = student.Name\r\n              .trim()\r\n              .replace(/[^a-zA-Z0-9\\s]/g, '')\r\n              .replace(/\\s+/g, '_')\r\n              .substring(0, 50);\r\n\r\n            const archiveFilename = `${cleanStudentName}_Resume${fileExtension}`;\r\n            \r\n            archive.file(resumePath, { name: archiveFilename });\r\n            filesAdded++;\r\n            console.log(`📄 Added to archive: ${archiveFilename}`);\r\n          } else {\r\n            console.warn(`⚠️ Resume file not found for ${student.Name}: ${resumePath}`);\r\n            filesSkipped++;\r\n          }\r\n        } catch (fileError) {\r\n          console.error(`❌ Error processing resume for ${student.Name}:`, fileError.message);\r\n          filesSkipped++;\r\n        }\r\n      }\r\n\r\n      archive.finalize();\r\n\r\n      archive.on('end', () => {\r\n        console.log(`✅ Bulk download completed: ${filesAdded} files added, ${filesSkipped} files skipped`);\r\n      });\r\n\r\n      archive.on('error', (error) => {\r\n        console.error('❌ Error creating zip archive:', error);\r\n        if (!res.headersSent) {\r\n          res.status(500).json({ error: 'Failed to create resume archive' });\r\n        }\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error in bulk download:', error);\r\n      if (!res.headersSent) {\r\n        res.status(500).json({ error: 'Failed to process bulk download' });\r\n      }\r\n    }\r\n  },\r\n\r\n  // ➤ Upload Excel file & process\r\n  uploadExcel: async (req, res) => {\r\n    try {\r\n      if (!req.file) {\r\n        return res.status(400).json({ error: 'No file uploaded' });\r\n      }\r\n\r\n      const filePath = req.file.path;\r\n      const result = await excelService.processExcelFile(filePath);\r\n\r\n      res.json({\r\n        message: 'Excel file processed successfully',\r\n        summary: result\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error processing Excel file:', error.message, error.stack);\r\n      res.status(500).json({ error: 'Failed to process Excel file' });\r\n    }\r\n  },\r\n\r\n  // ➤ Download sample Excel template\r\n  downloadSampleExcel: async (req, res) => {\r\n    try {\r\n      const buffer = excelService.generateSampleExcel();\r\n      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\r\n      res.setHeader('Content-Disposition', 'attachment; filename=\"student-template.xlsx\"');\r\n      res.send(buffer);\r\n    } catch (error) {\r\n      console.error('❌ Error generating sample:', error);\r\n      res.status(500).json({ error: 'Failed to generate sample template' });\r\n    }\r\n  },\r\n\r\n  // ➤ Send invitation emails\r\n  sendInvitations: async (req, res) => {\r\n    try {\r\n      const { studentIds } = req.body;\r\n\r\n      if (!Array.isArray(studentIds) || studentIds.length === 0) {\r\n        return res.status(400).json({ error: 'No student IDs provided' });\r\n      }\r\n\r\n      const pool = await getPool();\r\n      const request = pool.request();\r\n\r\n      // Build parameterized query inputs\r\n      studentIds.forEach((id, index) => {\r\n        request.input(`id${index}`, sql.Int, id);\r\n      });\r\n\r\n      const query = `\r\n        SELECT * FROM Students\r\n        WHERE Id IN (${studentIds.map((_, i) => `@id${i}`).join(',')})\r\n      `;\r\n\r\n      const students = await request.query(query);\r\n\r\n      if (students.recordset.length === 0) {\r\n        return res.status(404).json({ error: 'No students found for given IDs' });\r\n      }\r\n\r\n      console.log(\"📩 Sending invitations to:\", students.recordset.length, \"students\");\r\n\r\n      // Send all invitations in parallel with error handling\r\n      const invitationPromises = students.recordset.map(async (student) => {\r\n        try {\r\n          const result = await emailService.sendInvitationEmail(student);\r\n          return { \r\n            success: true, \r\n            student: { id: student.Id, name: student.Name, email: student.Email },\r\n            ...result \r\n          };\r\n        } catch (err) {\r\n          console.error(`❌ Failed to send email to ${student.Email}:`, err.message);\r\n          return { \r\n            success: false, \r\n            error: err.message, \r\n            student: { id: student.Id, name: student.Name, email: student.Email }\r\n          };\r\n        }\r\n      });\r\n\r\n      const results = await Promise.all(invitationPromises);\r\n      \r\n      // Count success/failure\r\n      const successful = results.filter(r => r.success).length;\r\n      const failed = results.filter(r => !r.success).length;\r\n\r\n      console.log(`📊 Invitation results: ${successful} successful, ${failed} failed`);\r\n\r\n      res.json({\r\n        message: 'Invitation process completed',\r\n        summary: {\r\n          total: results.length,\r\n          successful,\r\n          failed\r\n        },\r\n        results\r\n      });\r\n    } catch (error) {\r\n      console.error('🔥 Error in sendInvitations:', error);\r\n      res.status(500).json({ error: 'Failed to send invitations', details: error.message });\r\n    }\r\n  },\r\n\r\n  // ➤ Delete student by ID\r\n  deleteStudent: async (req, res) => {\r\n    try {\r\n      const id = parseInt(req.params.id);\r\n      if (isNaN(id)) {\r\n        return res.status(400).json({ error: 'Invalid student ID' });\r\n      }\r\n\r\n      const pool = await getPool();\r\n\r\n      // Get student info before deletion (for file cleanup)\r\n      const studentInfo = await pool.request()\r\n        .input('id', sql.Int, id)\r\n        .query('SELECT Name, ResumeLink FROM Students WHERE Id = @id');\r\n\r\n      // Check if student is referenced by Interviews or other tables\r\n      const refCheck = await pool.request()\r\n        .input('id', sql.Int, id)\r\n        .query(`\r\n          SELECT COUNT(*) AS count,\r\n          (SELECT TOP 1 Status FROM Interviews WHERE StudentId = @id) AS InterviewStatus\r\n          FROM Interviews WHERE StudentId = @id\r\n        `);\r\n\r\n      if (refCheck.recordset[0].count > 0) {\r\n        const interviewStatus = refCheck.recordset[0].InterviewStatus;\r\n        const errorMessage = `Cannot delete student with ${interviewStatus.toLowerCase()} interview`;\r\n        console.error(`Delete blocked: ${errorMessage} for student ID ${id}`);\r\n        return res.status(400).json({ \r\n          error: errorMessage,\r\n          interviewStatus: interviewStatus\r\n        });\r\n      }\r\n\r\n      // Proceed to delete student\r\n      const deleteResult = await pool.request()\r\n        .input('id', sql.Int, id)\r\n        .query('DELETE FROM Students WHERE Id = @id');\r\n\r\n      if (deleteResult.rowsAffected[0] === 0) {\r\n        return res.status(404).json({ error: 'Student not found' });\r\n      }\r\n\r\n      // Clean up resume file if exists\r\n      if (studentInfo.recordset.length > 0 && studentInfo.recordset[0].ResumeLink) {\r\n        try {\r\n          const resumePath = studentInfo.recordset[0].ResumeLink;\r\n          let actualPath = resumePath;\r\n          \r\n          if (!path.isAbsolute(resumePath)) {\r\n            actualPath = path.join(__dirname, '..', resumePath);\r\n          }\r\n          \r\n          if (fs.existsSync(actualPath)) {\r\n            fs.unlinkSync(actualPath);\r\n            console.log('🗑️ Resume file deleted:', actualPath);\r\n          }\r\n        } catch (fileError) {\r\n          console.warn('⚠️ Could not delete resume file:', fileError.message);\r\n        }\r\n      }\r\n\r\n      console.log('🗑️ Student deleted:', id);\r\n      res.json({ message: 'Student deleted successfully' });\r\n    } catch (error) {\r\n      console.error('❌ Error deleting student:', error.message || error);\r\n      res.status(500).json({ error: error.message || 'Failed to delete student' });\r\n    }\r\n  },\r\n\r\n  // ➤ Bulk delete students by date range\r\n  bulkDeleteByDate: async (req, res) => {\r\n    try {\r\n      const { start, end } = req.query;\r\n      if (!start || !end) {\r\n        return res.status(400).json({ error: 'Missing start or end date' });\r\n      }\r\n      \r\n      const pool = await getPool();\r\n      \r\n      // First check how many students would be affected\r\n      const checkResult = await pool.request()\r\n        .input('start', sql.DateTime2, new Date(start))\r\n        .input('end', sql.DateTime2, new Date(end))\r\n        .query(`\r\n          SELECT COUNT(*) as TotalCount,\r\n          COUNT(i.Id) as WithInterviews\r\n          FROM Students s\r\n          LEFT JOIN Interviews i ON s.Id = i.StudentId\r\n          WHERE s.CreatedAt BETWEEN @start AND @end\r\n        `);\r\n\r\n      const { TotalCount, WithInterviews } = checkResult.recordset[0];\r\n\r\n      if (WithInterviews > 0) {\r\n        return res.status(400).json({ \r\n          error: `Cannot delete students with interviews. ${WithInterviews} out of ${TotalCount} students have interview records.`,\r\n          studentsWithInterviews: WithInterviews,\r\n          totalStudents: TotalCount\r\n        });\r\n      }\r\n\r\n      // Get resume files to clean up\r\n      const resumeFiles = await pool.request()\r\n        .input('start', sql.DateTime2, new Date(start))\r\n        .input('end', sql.DateTime2, new Date(end))\r\n        .query(`\r\n          SELECT ResumeLink FROM Students \r\n          WHERE CreatedAt BETWEEN @start AND @end \r\n          AND ResumeLink IS NOT NULL\r\n          AND Id NOT IN (SELECT DISTINCT StudentId FROM Interviews WHERE StudentId IS NOT NULL)\r\n        `);\r\n\r\n      // Proceed with deletion if no interviews found\r\n      const result = await pool.request()\r\n        .input('start', sql.DateTime2, new Date(start))\r\n        .input('end', sql.DateTime2, new Date(end))\r\n        .query(`\r\n          DELETE FROM Students \r\n          WHERE CreatedAt BETWEEN @start AND @end\r\n          AND Id NOT IN (SELECT DISTINCT StudentId FROM Interviews WHERE StudentId IS NOT NULL)\r\n        `);\r\n\r\n      // Clean up resume files\r\n      let filesDeleted = 0;\r\n      for (const row of resumeFiles.recordset) {\r\n        try {\r\n          let resumePath = row.ResumeLink;\r\n          if (!path.isAbsolute(resumePath)) {\r\n            resumePath = path.join(__dirname, '..', resumePath);\r\n          }\r\n          \r\n          if (fs.existsSync(resumePath)) {\r\n            fs.unlinkSync(resumePath);\r\n            filesDeleted++;\r\n          }\r\n        } catch (fileError) {\r\n          console.warn('⚠️ Could not delete resume file:', fileError.message);\r\n        }\r\n      }\r\n\r\n      console.log(`🗑️ Bulk deleted ${result.rowsAffected[0]} students and ${filesDeleted} resume files from ${start} to ${end}`);\r\n      res.json({ \r\n        message: 'Students deleted successfully',\r\n        deletedCount: result.rowsAffected[0],\r\n        filesDeleted,\r\n        dateRange: { start, end }\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error in bulkDeleteByDate:', error);\r\n      res.status(500).json({ error: 'Failed to bulk delete students' });\r\n    }\r\n  },\r\n\r\n  // ➤ Get student interview status (NEW - for admin)\r\n  getStudentInterviewStatus: async (req, res) => {\r\n    try {\r\n      const { studentId } = req.params;\r\n      \r\n      if (!studentId) {\r\n        return res.status(400).json({ error: 'Student ID is required' });\r\n      }\r\n\r\n      const pool = await getPool();\r\n      const result = await pool.request()\r\n        .input('studentId', sql.Int, parseInt(studentId))\r\n        .query(`\r\n          SELECT \r\n            s.*,\r\n            i.Status as InterviewStatus,\r\n            i.InvitationToken,\r\n            i.TokenExpiredAt,\r\n            i.SlotId,\r\n            i.Interviewer,\r\n            i.MeetingLink,\r\n            i.CreatedAt as InvitationSentAt,\r\n            sl.SlotDateTime\r\n          FROM Students s\r\n          LEFT JOIN Interviews i ON s.Id = i.StudentId\r\n          LEFT JOIN InterviewSlots sl ON i.SlotId = sl.Id\r\n          WHERE s.Id = @studentId\r\n        `);\r\n\r\n      if (result.recordset.length === 0) {\r\n        return res.status(404).json({ error: 'Student not found' });\r\n      }\r\n\r\n      const studentData = result.recordset[0];\r\n      res.json({\r\n        student: {\r\n          id: studentData.Id,\r\n          name: studentData.Name,\r\n          email: studentData.Email,\r\n          phone: studentData.Phone,\r\n          hasResume: !!studentData.ResumeLink,\r\n          resumeFileName: studentData.ResumeFileName\r\n        },\r\n        interview: {\r\n          status: studentData.InterviewStatus || 'Not Invited',\r\n          tokenExpired: !!studentData.TokenExpiredAt,\r\n          tokenExpiredAt: studentData.TokenExpiredAt,\r\n          slotId: studentData.SlotId,\r\n          slotDateTime: studentData.SlotDateTime,\r\n          interviewer: studentData.Interviewer,\r\n          meetingLink: studentData.MeetingLink,\r\n          invitationSentAt: studentData.InvitationSentAt\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error fetching student status:', error);\r\n      res.status(500).json({ error: 'Failed to fetch student status' });\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = studentController;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}