{"ast":null,"code":"import api from './api';\nconst slotService = {\n  getSlots: async () => {\n    try {\n      const response = await api.get('/slots');\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get slots:', error);\n      throw error;\n    }\n  },\n  getAvailableSlots: async () => {\n    try {\n      const response = await api.get('/slots/available');\n      console.log('📅 Available slots loaded:', response.data.length);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get available slots:', error);\n      throw error;\n    }\n  },\n  createSlot: async slotData => {\n    try {\n      if (!slotData || !slotData.slotDateTime) {\n        throw new Error('Slot date and time are required');\n      }\n      const response = await api.post('/slots', slotData);\n      console.log('✅ Slot created successfully:', response.data);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to create slot:', error);\n      throw error;\n    }\n  },\n  // ENHANCED: Create multiple slots at once with detailed logging\n  createBulkSlots: async slotsData => {\n    try {\n      if (!Array.isArray(slotsData) || slotsData.length === 0) {\n        throw new Error('Slots data array is required');\n      }\n      console.log('📅 Creating bulk slots:', slotsData.length);\n      console.log('📋 First few slots data:', JSON.stringify(slotsData.slice(0, 3), null, 2));\n\n      // Validate all slots before sending\n      slotsData.forEach((slot, index) => {\n        if (!slot.slotDateTime) {\n          throw new Error(`Slot ${index + 1}: Date and time are required`);\n        }\n        if (!slot.interviewer) {\n          throw new Error(`Slot ${index + 1}: Interviewer is required`);\n        }\n\n        // Additional validation\n        const date = new Date(slot.slotDateTime);\n        if (isNaN(date.getTime())) {\n          throw new Error(`Slot ${index + 1}: Invalid date format - ${slot.slotDateTime}`);\n        }\n      });\n      const requestData = {\n        slots: slotsData\n      };\n      console.log('📤 Sending request data:', JSON.stringify(requestData, null, 2));\n      const response = await api.post('/slots/bulk', requestData, {\n        timeout: 30000 // 30 second timeout for bulk operations\n      });\n      console.log('✅ Bulk slots created:', {\n        total: response.data.summary.total,\n        successful: response.data.summary.successful,\n        failed: response.data.summary.failed,\n        duplicates: response.data.summary.duplicates\n      });\n      return response.data.summary;\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error('❌ Failed to create bulk slots:', error);\n      console.error('❌ Error details:', {\n        message: error.message,\n        response: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data,\n        status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status,\n        config: error.config\n      });\n      if (error.response) {\n        var _error$response$data;\n        const serverError = ((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Server error occurred';\n        console.error('❌ Server error details:', error.response.data);\n        throw new Error(serverError);\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timeout. The bulk operation may still be processing.');\n      } else {\n        throw new Error(error.message || 'Failed to create bulk slots');\n      }\n    }\n  },\n  bookSlot: async (slotId, token) => {\n    try {\n      console.log('📅 Attempting to book slot:', {\n        slotId,\n        token: token ? `${token.substring(0, 10)}...` : 'missing'\n      });\n\n      // Validate input parameters\n      if (!slotId) {\n        throw new Error('Slot ID is required');\n      }\n      if (!token) {\n        throw new Error('Authentication token is required');\n      }\n\n      // Ensure slotId is a number and token is a clean string\n      const bookingData = {\n        slotId: parseInt(slotId),\n        token: token.trim()\n      };\n\n      // Validate slotId is a valid number\n      if (isNaN(bookingData.slotId)) {\n        throw new Error('Invalid slot ID format');\n      }\n      const response = await api.post('/slots/book', bookingData);\n      console.log('✅ Slot booked successfully:', {\n        slotId: bookingData.slotId,\n        studentName: response.data.studentName,\n        slotDateTime: response.data.slotDateTime\n      });\n      return response.data;\n    } catch (error) {\n      console.error('❌ Failed to book slot:', error);\n\n      // Enhanced error handling with specific messages\n      if (error.response) {\n        var _error$response$data2;\n        // Server responded with error status\n        const serverError = ((_error$response$data2 = error.response.data) === null || _error$response$data2 === void 0 ? void 0 : _error$response$data2.error) || 'Server error occurred';\n        const statusCode = error.response.status;\n\n        // Handle specific status codes\n        switch (statusCode) {\n          case 400:\n            throw new Error(serverError);\n          case 401:\n            throw new Error('Authentication failed. Please check your invitation link.');\n          case 404:\n            throw new Error('Slot not found or invitation token is invalid.');\n          case 409:\n            throw new Error('Slot is no longer available. Please select another slot.');\n          case 500:\n            throw new Error('Server error. Please try again later.');\n          default:\n            throw new Error(serverError);\n        }\n      } else if (error.request) {\n        // Request timeout or network error\n        if (error.code === 'ECONNABORTED') {\n          throw new Error('Request timeout. Please check your connection and try again.');\n        }\n        throw new Error('Network error. Please check your internet connection.');\n      } else {\n        // Other errors (validation, etc.)\n        throw new Error(error.message || 'An unexpected error occurred while booking the slot.');\n      }\n    }\n  },\n  deleteSlot: async id => {\n    try {\n      if (!id) {\n        throw new Error('Slot ID is required');\n      }\n      const slotId = parseInt(id);\n      if (isNaN(slotId)) {\n        throw new Error('Invalid slot ID format');\n      }\n      const response = await api.delete(`/slots/${slotId}`);\n      console.log('🗑️ Slot deleted successfully:', slotId);\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response4;\n      console.error('Failed to delete slot:', error);\n      if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n        throw new Error('Slot not found');\n      } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 400) {\n        var _error$response$data3;\n        throw new Error(((_error$response$data3 = error.response.data) === null || _error$response$data3 === void 0 ? void 0 : _error$response$data3.error) || 'Cannot delete this slot');\n      }\n      throw error;\n    }\n  },\n  // NEW: Bulk delete slots\n  deleteBulkSlots: async slotIds => {\n    try {\n      if (!Array.isArray(slotIds) || slotIds.length === 0) {\n        throw new Error('Slot IDs array is required');\n      }\n      console.log('🗑️ Deleting bulk slots:', slotIds.length);\n      const response = await api.delete('/slots/bulk', {\n        data: {\n          slotIds\n        }\n      });\n      console.log('✅ Bulk slots deleted:', response.data);\n      return response.data;\n    } catch (error) {\n      console.error('❌ Failed to delete bulk slots:', error);\n      throw error;\n    }\n  },\n  // Helper method to validate slot data\n  validateSlotData: slotData => {\n    if (!slotData) {\n      throw new Error('Slot data is required');\n    }\n    if (!slotData.slotDateTime) {\n      throw new Error('Slot date and time are required');\n    }\n    const slotDate = new Date(slotData.slotDateTime);\n    const now = new Date();\n    if (isNaN(slotDate.getTime())) {\n      throw new Error('Invalid date format');\n    }\n    if (slotDate <= now) {\n      throw new Error('Slot date must be in the future');\n    }\n    return true;\n  },\n  // NEW: Validate bulk slot data\n  validateBulkSlotData: slotsData => {\n    if (!Array.isArray(slotsData) || slotsData.length === 0) {\n      throw new Error('Slots data array is required');\n    }\n    if (slotsData.length > 500) {\n      throw new Error('Cannot create more than 500 slots at once');\n    }\n    const errors = [];\n    slotsData.forEach((slot, index) => {\n      try {\n        slotService.validateSlotData(slot);\n        if (!slot.interviewer) {\n          errors.push(`Slot ${index + 1}: Interviewer is required`);\n        }\n      } catch (error) {\n        errors.push(`Slot ${index + 1}: ${error.message}`);\n      }\n    });\n    if (errors.length > 0) {\n      throw new Error('Validation errors:\\n' + errors.join('\\n'));\n    }\n    return true;\n  },\n  // Helper method to format slot date for display\n  formatSlotDateTime: dateTimeString => {\n    try {\n      const date = new Date(dateTimeString);\n      return {\n        date: date.toLocaleDateString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric'\n        }),\n        time: date.toLocaleTimeString('en-US', {\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: true\n        }),\n        full: date.toLocaleString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric',\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: true\n        }),\n        isToday: date.toDateString() === new Date().toDateString(),\n        isTomorrow: date.toDateString() === new Date(Date.now() + 86400000).toDateString(),\n        dayOfWeek: date.toLocaleDateString('en-US', {\n          weekday: 'short'\n        }),\n        shortDate: date.toLocaleDateString('en-US', {\n          month: 'short',\n          day: 'numeric'\n        }),\n        shortTime: date.toLocaleTimeString('en-US', {\n          hour: 'numeric',\n          minute: '2-digit',\n          hour12: true\n        })\n      };\n    } catch (error) {\n      console.error('Error formatting date:', error);\n      return {\n        date: 'Invalid Date',\n        time: 'Invalid Time',\n        full: 'Invalid Date/Time',\n        isToday: false,\n        isTomorrow: false,\n        dayOfWeek: '---',\n        shortDate: '---',\n        shortTime: '---'\n      };\n    }\n  },\n  // Helper method to check if a slot is bookable\n  isSlotBookable: slotDateTime => {\n    const slotDate = new Date(slotDateTime);\n    const now = new Date();\n    const bufferMinutes = 30; // 30-minute buffer\n\n    return slotDate > new Date(now.getTime() + bufferMinutes * 60 * 1000);\n  },\n  // NEW: Generate slot times based on duration\n  generateSlotTimes: (startTime, endTime, durationMinutes) => {\n    try {\n      const slots = [];\n      const [startHour, startMinute] = startTime.split(':').map(Number);\n      const [endHour, endMinute] = endTime.split(':').map(Number);\n      let currentTime = new Date();\n      currentTime.setHours(startHour, startMinute, 0, 0);\n      const endDateTime = new Date();\n      endDateTime.setHours(endHour, endMinute, 0, 0);\n      while (currentTime < endDateTime) {\n        // Check if there's enough time for a complete slot\n        const nextSlot = new Date(currentTime.getTime() + durationMinutes * 60000);\n        if (nextSlot <= endDateTime) {\n          slots.push({\n            time: currentTime.toTimeString().slice(0, 5),\n            // HH:MM format\n            display: currentTime.toLocaleTimeString('en-US', {\n              hour: 'numeric',\n              minute: '2-digit',\n              hour12: true\n            }),\n            value: currentTime.toTimeString()\n          });\n        }\n        currentTime.setTime(currentTime.getTime() + durationMinutes * 60000);\n      }\n      return slots;\n    } catch (error) {\n      console.error('Error generating slot times:', error);\n      return [];\n    }\n  },\n  // NEW: Calculate total slots for date range\n  calculateTotalSlots: (startDate, endDate, startTime, endTime, duration, skipWeekends = true) => {\n    try {\n      let totalSlots = 0;\n      const currentDate = new Date(startDate);\n      const finalDate = new Date(endDate);\n      while (currentDate <= finalDate) {\n        // Skip weekends if option is selected\n        if (skipWeekends && (currentDate.getDay() === 0 || currentDate.getDay() === 6)) {\n          currentDate.setDate(currentDate.getDate() + 1);\n          continue;\n        }\n\n        // Calculate slots for this day\n        const daySlots = slotService.generateSlotTimes(startTime, endTime, duration);\n        totalSlots += daySlots.length;\n        currentDate.setDate(currentDate.getDate() + 1);\n      }\n      return totalSlots;\n    } catch (error) {\n      console.error('Error calculating total slots:', error);\n      return 0;\n    }\n  },\n  // Method to get slot statistics\n  getSlotStats: async () => {\n    try {\n      const [allSlots, availableSlots] = await Promise.all([slotService.getSlots(), slotService.getAvailableSlots()]);\n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      const tomorrow = new Date(today.getTime() + 86400000);\n      const stats = {\n        total: allSlots.length,\n        available: availableSlots.length,\n        booked: allSlots.filter(slot => slot.IsBooked).length,\n        today: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          return slotDate.toDateString() === today.toDateString();\n        }).length,\n        tomorrow: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          return slotDate.toDateString() === tomorrow.toDateString();\n        }).length,\n        upcoming: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          return slotDate > tomorrow;\n        }).length,\n        thisWeek: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          const weekFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);\n          return slotDate <= weekFromNow;\n        }).length,\n        byInterviewer: allSlots.reduce((acc, slot) => {\n          const interviewer = slot.Interviewer || 'Unassigned';\n          acc[interviewer] = (acc[interviewer] || 0) + 1;\n          return acc;\n        }, {})\n      };\n      console.log('📊 Slot statistics:', stats);\n      return stats;\n    } catch (error) {\n      console.error('Failed to get slot statistics:', error);\n      throw error;\n    }\n  },\n  // NEW: Get slots by date range\n  getSlotsByDateRange: async (startDate, endDate) => {\n    try {\n      const response = await api.get('/slots/range', {\n        params: {\n          startDate,\n          endDate\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get slots by date range:', error);\n      throw error;\n    }\n  },\n  // NEW: Get slots by interviewer\n  getSlotsByInterviewer: async interviewer => {\n    try {\n      const response = await api.get('/slots/interviewer', {\n        params: {\n          interviewer\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get slots by interviewer:', error);\n      throw error;\n    }\n  }\n};\nexport default slotService;","map":{"version":3,"names":["api","slotService","getSlots","response","get","data","error","console","getAvailableSlots","log","length","createSlot","slotData","slotDateTime","Error","post","createBulkSlots","slotsData","Array","isArray","JSON","stringify","slice","forEach","slot","index","interviewer","date","Date","isNaN","getTime","requestData","slots","timeout","total","summary","successful","failed","duplicates","_error$response","_error$response2","message","status","config","_error$response$data","serverError","code","bookSlot","slotId","token","substring","bookingData","parseInt","trim","studentName","_error$response$data2","statusCode","request","deleteSlot","id","delete","_error$response3","_error$response4","_error$response$data3","deleteBulkSlots","slotIds","validateSlotData","slotDate","now","validateBulkSlotData","errors","push","join","formatSlotDateTime","dateTimeString","toLocaleDateString","weekday","year","month","day","time","toLocaleTimeString","hour","minute","hour12","full","toLocaleString","isToday","toDateString","isTomorrow","dayOfWeek","shortDate","shortTime","isSlotBookable","bufferMinutes","generateSlotTimes","startTime","endTime","durationMinutes","startHour","startMinute","split","map","Number","endHour","endMinute","currentTime","setHours","endDateTime","nextSlot","toTimeString","display","value","setTime","calculateTotalSlots","startDate","endDate","duration","skipWeekends","totalSlots","currentDate","finalDate","getDay","setDate","getDate","daySlots","getSlotStats","allSlots","availableSlots","Promise","all","today","getFullYear","getMonth","tomorrow","stats","available","booked","filter","IsBooked","SlotDateTime","upcoming","thisWeek","weekFromNow","byInterviewer","reduce","acc","Interviewer","getSlotsByDateRange","params","getSlotsByInterviewer"],"sources":["E:/Downloads/interview-scheduler/interview-scheduler-frontend/src/services/slotService.js"],"sourcesContent":["import api from './api';\r\n\r\nconst slotService = {\r\n    getSlots: async () => {\r\n        try {\r\n            const response = await api.get('/slots');\r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('Failed to get slots:', error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    getAvailableSlots: async () => {\r\n        try {\r\n            const response = await api.get('/slots/available');\r\n            console.log('📅 Available slots loaded:', response.data.length);\r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('Failed to get available slots:', error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    createSlot: async (slotData) => {\r\n        try {\r\n            if (!slotData || !slotData.slotDateTime) {\r\n                throw new Error('Slot date and time are required');\r\n            }\r\n\r\n            const response = await api.post('/slots', slotData);\r\n            console.log('✅ Slot created successfully:', response.data);\r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('Failed to create slot:', error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // ENHANCED: Create multiple slots at once with detailed logging\r\n    createBulkSlots: async (slotsData) => {\r\n        try {\r\n            if (!Array.isArray(slotsData) || slotsData.length === 0) {\r\n                throw new Error('Slots data array is required');\r\n            }\r\n\r\n            console.log('📅 Creating bulk slots:', slotsData.length);\r\n            console.log('📋 First few slots data:', JSON.stringify(slotsData.slice(0, 3), null, 2));\r\n\r\n            // Validate all slots before sending\r\n            slotsData.forEach((slot, index) => {\r\n                if (!slot.slotDateTime) {\r\n                    throw new Error(`Slot ${index + 1}: Date and time are required`);\r\n                }\r\n                if (!slot.interviewer) {\r\n                    throw new Error(`Slot ${index + 1}: Interviewer is required`);\r\n                }\r\n\r\n                // Additional validation\r\n                const date = new Date(slot.slotDateTime);\r\n                if (isNaN(date.getTime())) {\r\n                    throw new Error(`Slot ${index + 1}: Invalid date format - ${slot.slotDateTime}`);\r\n                }\r\n            });\r\n\r\n            const requestData = { slots: slotsData };\r\n            console.log('📤 Sending request data:', JSON.stringify(requestData, null, 2));\r\n\r\n            const response = await api.post('/slots/bulk', requestData, {\r\n                timeout: 30000 // 30 second timeout for bulk operations\r\n            });\r\n\r\n            console.log('✅ Bulk slots created:', {\r\n                total: response.data.summary.total,\r\n                successful: response.data.summary.successful,\r\n                failed: response.data.summary.failed,\r\n                duplicates: response.data.summary.duplicates\r\n            });\r\n\r\n            return response.data.summary;\r\n        } catch (error) {\r\n            console.error('❌ Failed to create bulk slots:', error);\r\n            console.error('❌ Error details:', {\r\n                message: error.message,\r\n                response: error.response?.data,\r\n                status: error.response?.status,\r\n                config: error.config\r\n            });\r\n            \r\n            if (error.response) {\r\n                const serverError = error.response.data?.error || 'Server error occurred';\r\n                console.error('❌ Server error details:', error.response.data);\r\n                throw new Error(serverError);\r\n            } else if (error.code === 'ECONNABORTED') {\r\n                throw new Error('Request timeout. The bulk operation may still be processing.');\r\n            } else {\r\n                throw new Error(error.message || 'Failed to create bulk slots');\r\n            }\r\n        }\r\n    },\r\n\r\n    bookSlot: async (slotId, token) => {\r\n        try {\r\n            console.log('📅 Attempting to book slot:', { slotId, token: token ? `${token.substring(0, 10)}...` : 'missing' });\r\n            \r\n            // Validate input parameters\r\n            if (!slotId) {\r\n                throw new Error('Slot ID is required');\r\n            }\r\n            \r\n            if (!token) {\r\n                throw new Error('Authentication token is required');\r\n            }\r\n\r\n            // Ensure slotId is a number and token is a clean string\r\n            const bookingData = {\r\n                slotId: parseInt(slotId), \r\n                token: token.trim()\r\n            };\r\n\r\n            // Validate slotId is a valid number\r\n            if (isNaN(bookingData.slotId)) {\r\n                throw new Error('Invalid slot ID format');\r\n            }\r\n\r\n            const response = await api.post('/slots/book', bookingData);\r\n            \r\n            console.log('✅ Slot booked successfully:', {\r\n                slotId: bookingData.slotId,\r\n                studentName: response.data.studentName,\r\n                slotDateTime: response.data.slotDateTime\r\n            });\r\n            \r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('❌ Failed to book slot:', error);\r\n            \r\n            // Enhanced error handling with specific messages\r\n            if (error.response) {\r\n                // Server responded with error status\r\n                const serverError = error.response.data?.error || 'Server error occurred';\r\n                const statusCode = error.response.status;\r\n                \r\n                // Handle specific status codes\r\n                switch (statusCode) {\r\n                    case 400:\r\n                        throw new Error(serverError);\r\n                    case 401:\r\n                        throw new Error('Authentication failed. Please check your invitation link.');\r\n                    case 404:\r\n                        throw new Error('Slot not found or invitation token is invalid.');\r\n                    case 409:\r\n                        throw new Error('Slot is no longer available. Please select another slot.');\r\n                    case 500:\r\n                        throw new Error('Server error. Please try again later.');\r\n                    default:\r\n                        throw new Error(serverError);\r\n                }\r\n            } else if (error.request) {\r\n                // Request timeout or network error\r\n                if (error.code === 'ECONNABORTED') {\r\n                    throw new Error('Request timeout. Please check your connection and try again.');\r\n                }\r\n                throw new Error('Network error. Please check your internet connection.');\r\n            } else {\r\n                // Other errors (validation, etc.)\r\n                throw new Error(error.message || 'An unexpected error occurred while booking the slot.');\r\n            }\r\n        }\r\n    },\r\n\r\n    deleteSlot: async (id) => {\r\n        try {\r\n            if (!id) {\r\n                throw new Error('Slot ID is required');\r\n            }\r\n\r\n            const slotId = parseInt(id);\r\n            if (isNaN(slotId)) {\r\n                throw new Error('Invalid slot ID format');\r\n            }\r\n\r\n            const response = await api.delete(`/slots/${slotId}`);\r\n            console.log('🗑️ Slot deleted successfully:', slotId);\r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('Failed to delete slot:', error);\r\n            \r\n            if (error.response?.status === 404) {\r\n                throw new Error('Slot not found');\r\n            } else if (error.response?.status === 400) {\r\n                throw new Error(error.response.data?.error || 'Cannot delete this slot');\r\n            }\r\n            \r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // NEW: Bulk delete slots\r\n    deleteBulkSlots: async (slotIds) => {\r\n        try {\r\n            if (!Array.isArray(slotIds) || slotIds.length === 0) {\r\n                throw new Error('Slot IDs array is required');\r\n            }\r\n\r\n            console.log('🗑️ Deleting bulk slots:', slotIds.length);\r\n\r\n            const response = await api.delete('/slots/bulk', {\r\n                data: { slotIds }\r\n            });\r\n\r\n            console.log('✅ Bulk slots deleted:', response.data);\r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('❌ Failed to delete bulk slots:', error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // Helper method to validate slot data\r\n    validateSlotData: (slotData) => {\r\n        if (!slotData) {\r\n            throw new Error('Slot data is required');\r\n        }\r\n\r\n        if (!slotData.slotDateTime) {\r\n            throw new Error('Slot date and time are required');\r\n        }\r\n\r\n        const slotDate = new Date(slotData.slotDateTime);\r\n        const now = new Date();\r\n\r\n        if (isNaN(slotDate.getTime())) {\r\n            throw new Error('Invalid date format');\r\n        }\r\n\r\n        if (slotDate <= now) {\r\n            throw new Error('Slot date must be in the future');\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // NEW: Validate bulk slot data\r\n    validateBulkSlotData: (slotsData) => {\r\n        if (!Array.isArray(slotsData) || slotsData.length === 0) {\r\n            throw new Error('Slots data array is required');\r\n        }\r\n\r\n        if (slotsData.length > 500) {\r\n            throw new Error('Cannot create more than 500 slots at once');\r\n        }\r\n\r\n        const errors = [];\r\n        slotsData.forEach((slot, index) => {\r\n            try {\r\n                slotService.validateSlotData(slot);\r\n                \r\n                if (!slot.interviewer) {\r\n                    errors.push(`Slot ${index + 1}: Interviewer is required`);\r\n                }\r\n            } catch (error) {\r\n                errors.push(`Slot ${index + 1}: ${error.message}`);\r\n            }\r\n        });\r\n\r\n        if (errors.length > 0) {\r\n            throw new Error('Validation errors:\\n' + errors.join('\\n'));\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // Helper method to format slot date for display\r\n    formatSlotDateTime: (dateTimeString) => {\r\n        try {\r\n            const date = new Date(dateTimeString);\r\n            return {\r\n                date: date.toLocaleDateString('en-US', {\r\n                    weekday: 'long',\r\n                    year: 'numeric',\r\n                    month: 'long',\r\n                    day: 'numeric'\r\n                }),\r\n                time: date.toLocaleTimeString('en-US', {\r\n                    hour: '2-digit',\r\n                    minute: '2-digit',\r\n                    hour12: true\r\n                }),\r\n                full: date.toLocaleString('en-US', {\r\n                    weekday: 'long',\r\n                    year: 'numeric',\r\n                    month: 'long',\r\n                    day: 'numeric',\r\n                    hour: '2-digit',\r\n                    minute: '2-digit',\r\n                    hour12: true\r\n                }),\r\n                isToday: date.toDateString() === new Date().toDateString(),\r\n                isTomorrow: date.toDateString() === new Date(Date.now() + 86400000).toDateString(),\r\n                dayOfWeek: date.toLocaleDateString('en-US', { weekday: 'short' }),\r\n                shortDate: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),\r\n                shortTime: date.toLocaleTimeString('en-US', { \r\n                    hour: 'numeric', \r\n                    minute: '2-digit',\r\n                    hour12: true \r\n                })\r\n            };\r\n        } catch (error) {\r\n            console.error('Error formatting date:', error);\r\n            return {\r\n                date: 'Invalid Date',\r\n                time: 'Invalid Time',\r\n                full: 'Invalid Date/Time',\r\n                isToday: false,\r\n                isTomorrow: false,\r\n                dayOfWeek: '---',\r\n                shortDate: '---',\r\n                shortTime: '---'\r\n            };\r\n        }\r\n    },\r\n\r\n    // Helper method to check if a slot is bookable\r\n    isSlotBookable: (slotDateTime) => {\r\n        const slotDate = new Date(slotDateTime);\r\n        const now = new Date();\r\n        const bufferMinutes = 30; // 30-minute buffer\r\n        \r\n        return slotDate > new Date(now.getTime() + (bufferMinutes * 60 * 1000));\r\n    },\r\n\r\n    // NEW: Generate slot times based on duration\r\n    generateSlotTimes: (startTime, endTime, durationMinutes) => {\r\n        try {\r\n            const slots = [];\r\n            \r\n            const [startHour, startMinute] = startTime.split(':').map(Number);\r\n            const [endHour, endMinute] = endTime.split(':').map(Number);\r\n            \r\n            let currentTime = new Date();\r\n            currentTime.setHours(startHour, startMinute, 0, 0);\r\n            \r\n            const endDateTime = new Date();\r\n            endDateTime.setHours(endHour, endMinute, 0, 0);\r\n            \r\n            while (currentTime < endDateTime) {\r\n                // Check if there's enough time for a complete slot\r\n                const nextSlot = new Date(currentTime.getTime() + (durationMinutes * 60000));\r\n                if (nextSlot <= endDateTime) {\r\n                    slots.push({\r\n                        time: currentTime.toTimeString().slice(0, 5), // HH:MM format\r\n                        display: currentTime.toLocaleTimeString('en-US', { \r\n                            hour: 'numeric', \r\n                            minute: '2-digit',\r\n                            hour12: true \r\n                        }),\r\n                        value: currentTime.toTimeString()\r\n                    });\r\n                }\r\n                currentTime.setTime(currentTime.getTime() + (durationMinutes * 60000));\r\n            }\r\n            \r\n            return slots;\r\n        } catch (error) {\r\n            console.error('Error generating slot times:', error);\r\n            return [];\r\n        }\r\n    },\r\n\r\n    // NEW: Calculate total slots for date range\r\n    calculateTotalSlots: (startDate, endDate, startTime, endTime, duration, skipWeekends = true) => {\r\n        try {\r\n            let totalSlots = 0;\r\n            const currentDate = new Date(startDate);\r\n            const finalDate = new Date(endDate);\r\n\r\n            while (currentDate <= finalDate) {\r\n                // Skip weekends if option is selected\r\n                if (skipWeekends && (currentDate.getDay() === 0 || currentDate.getDay() === 6)) {\r\n                    currentDate.setDate(currentDate.getDate() + 1);\r\n                    continue;\r\n                }\r\n\r\n                // Calculate slots for this day\r\n                const daySlots = slotService.generateSlotTimes(startTime, endTime, duration);\r\n                totalSlots += daySlots.length;\r\n\r\n                currentDate.setDate(currentDate.getDate() + 1);\r\n            }\r\n\r\n            return totalSlots;\r\n        } catch (error) {\r\n            console.error('Error calculating total slots:', error);\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    // Method to get slot statistics\r\n    getSlotStats: async () => {\r\n        try {\r\n            const [allSlots, availableSlots] = await Promise.all([\r\n                slotService.getSlots(),\r\n                slotService.getAvailableSlots()\r\n            ]);\r\n\r\n            const now = new Date();\r\n            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\r\n            const tomorrow = new Date(today.getTime() + 86400000);\r\n\r\n            const stats = {\r\n                total: allSlots.length,\r\n                available: availableSlots.length,\r\n                booked: allSlots.filter(slot => slot.IsBooked).length,\r\n                today: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    return slotDate.toDateString() === today.toDateString();\r\n                }).length,\r\n                tomorrow: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    return slotDate.toDateString() === tomorrow.toDateString();\r\n                }).length,\r\n                upcoming: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    return slotDate > tomorrow;\r\n                }).length,\r\n                thisWeek: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    const weekFromNow = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000));\r\n                    return slotDate <= weekFromNow;\r\n                }).length,\r\n                byInterviewer: allSlots.reduce((acc, slot) => {\r\n                    const interviewer = slot.Interviewer || 'Unassigned';\r\n                    acc[interviewer] = (acc[interviewer] || 0) + 1;\r\n                    return acc;\r\n                }, {})\r\n            };\r\n\r\n            console.log('📊 Slot statistics:', stats);\r\n            return stats;\r\n        } catch (error) {\r\n            console.error('Failed to get slot statistics:', error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // NEW: Get slots by date range\r\n    getSlotsByDateRange: async (startDate, endDate) => {\r\n        try {\r\n            const response = await api.get('/slots/range', {\r\n                params: { startDate, endDate }\r\n            });\r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('Failed to get slots by date range:', error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // NEW: Get slots by interviewer\r\n    getSlotsByInterviewer: async (interviewer) => {\r\n        try {\r\n            const response = await api.get('/slots/interviewer', {\r\n                params: { interviewer }\r\n            });\r\n            return response.data;\r\n        } catch (error) {\r\n            console.error('Failed to get slots by interviewer:', error);\r\n            throw error;\r\n        }\r\n    }\r\n};\r\n\r\nexport default slotService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}