{"ast":null,"code":"import api from './api';\nconst slotService = {\n  getSlots: async () => {\n    try {\n      const response = await api.get('/slots');\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  getAvailableSlots: async () => {\n    try {\n      const response = await api.get('/slots/available');\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  createSlot: async slotData => {\n    try {\n      if (!slotData || !slotData.slotDateTime) {\n        throw new Error('Slot date and time are required');\n      }\n      const response = await api.post('/slots', slotData);\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  // Create multiple slots at once\n  createBulkSlots: async slotsData => {\n    try {\n      if (!Array.isArray(slotsData) || slotsData.length === 0) {\n        throw new Error('Slots data array is required');\n      }\n\n      // Validate all slots before sending\n      slotsData.forEach((slot, index) => {\n        if (!slot.slotDateTime) {\n          throw new Error(`Slot ${index + 1}: Date and time are required`);\n        }\n        if (!slot.interviewer) {\n          throw new Error(`Slot ${index + 1}: Interviewer is required`);\n        }\n\n        // Additional validation\n        const date = new Date(slot.slotDateTime);\n        if (isNaN(date.getTime())) {\n          throw new Error(`Slot ${index + 1}: Invalid date format - ${slot.slotDateTime}`);\n        }\n      });\n      const requestData = {\n        slots: slotsData\n      };\n      const response = await api.post('/slots/bulk', requestData, {\n        timeout: 30000\n      });\n      return response.data.summary;\n    } catch (error) {\n      if (error.response) {\n        var _error$response$data;\n        const serverError = ((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Server error occurred';\n        throw new Error(serverError);\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timeout. The bulk operation may still be processing.');\n      } else {\n        throw new Error(error.message || 'Failed to create bulk slots');\n      }\n    }\n  },\n  bookSlot: async (slotId, token) => {\n    try {\n      // Validate input parameters\n      if (!slotId) {\n        throw new Error('Slot ID is required');\n      }\n      if (!token) {\n        throw new Error('Authentication token is required');\n      }\n\n      // Ensure slotId is a number and token is a clean string\n      const bookingData = {\n        slotId: parseInt(slotId),\n        token: token.trim()\n      };\n\n      // Validate slotId is a valid number\n      if (isNaN(bookingData.slotId)) {\n        throw new Error('Invalid slot ID format');\n      }\n      const response = await api.post('/slots/book', bookingData);\n      return response.data;\n    } catch (error) {\n      // Enhanced error handling with specific messages\n      if (error.response) {\n        var _error$response$data2;\n        const serverError = ((_error$response$data2 = error.response.data) === null || _error$response$data2 === void 0 ? void 0 : _error$response$data2.error) || 'Server error occurred';\n        const statusCode = error.response.status;\n\n        // Handle specific status codes\n        switch (statusCode) {\n          case 400:\n            throw new Error(serverError);\n          case 401:\n            throw new Error('Authentication failed. Please check your invitation link.');\n          case 404:\n            throw new Error('Slot not found or invitation token is invalid.');\n          case 409:\n            throw new Error('Slot is no longer available. Please select another slot.');\n          case 500:\n            throw new Error('Server error. Please try again later.');\n          default:\n            throw new Error(serverError);\n        }\n      } else if (error.request) {\n        if (error.code === 'ECONNABORTED') {\n          throw new Error('Request timeout. Please check your connection and try again.');\n        }\n        throw new Error('Network error. Please check your internet connection.');\n      } else {\n        throw new Error(error.message || 'An unexpected error occurred while booking the slot.');\n      }\n    }\n  },\n  deleteSlot: async id => {\n    try {\n      if (!id) {\n        throw new Error('Slot ID is required');\n      }\n      const slotId = parseInt(id);\n      if (isNaN(slotId)) {\n        throw new Error('Invalid slot ID format');\n      }\n      const response = await api.delete(`/slots/${slotId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response2;\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 404) {\n        throw new Error('Slot not found');\n      } else if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 400) {\n        var _error$response$data3;\n        throw new Error(((_error$response$data3 = error.response.data) === null || _error$response$data3 === void 0 ? void 0 : _error$response$data3.error) || 'Cannot delete this slot');\n      }\n      throw error;\n    }\n  },\n  // Bulk delete slots\n  deleteBulkSlots: async slotIds => {\n    try {\n      if (!Array.isArray(slotIds) || slotIds.length === 0) {\n        throw new Error('Slot IDs array is required');\n      }\n      const response = await api.delete('/slots/bulk', {\n        data: {\n          slotIds\n        }\n      });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  // Cancel booking\n  cancelBooking: async (slotId, reason = 'Cancelled by admin') => {\n    try {\n      if (!slotId) {\n        throw new Error('Slot ID is required');\n      }\n      const response = await api.delete(`/slots/${slotId}/cancel`, {\n        data: {\n          reason\n        }\n      });\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response4;\n      if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n        throw new Error('Booking not found');\n      } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 400) {\n        var _error$response$data4;\n        throw new Error(((_error$response$data4 = error.response.data) === null || _error$response$data4 === void 0 ? void 0 : _error$response$data4.error) || 'Cannot cancel this booking');\n      }\n      throw error;\n    }\n  },\n  // Helper method to validate slot data\n  validateSlotData: slotData => {\n    if (!slotData) {\n      throw new Error('Slot data is required');\n    }\n    if (!slotData.slotDateTime) {\n      throw new Error('Slot date and time are required');\n    }\n    const slotDate = new Date(slotData.slotDateTime);\n    const now = new Date();\n    if (isNaN(slotDate.getTime())) {\n      throw new Error('Invalid date format');\n    }\n    if (slotDate <= now) {\n      throw new Error('Slot date must be in the future');\n    }\n    return true;\n  },\n  // Validate bulk slot data\n  validateBulkSlotData: slotsData => {\n    if (!Array.isArray(slotsData) || slotsData.length === 0) {\n      throw new Error('Slots data array is required');\n    }\n    if (slotsData.length > 500) {\n      throw new Error('Cannot create more than 500 slots at once');\n    }\n    const errors = [];\n    slotsData.forEach((slot, index) => {\n      try {\n        slotService.validateSlotData(slot);\n        if (!slot.interviewer) {\n          errors.push(`Slot ${index + 1}: Interviewer is required`);\n        }\n      } catch (error) {\n        errors.push(`Slot ${index + 1}: ${error.message}`);\n      }\n    });\n    if (errors.length > 0) {\n      throw new Error('Validation errors:\\n' + errors.join('\\n'));\n    }\n    return true;\n  },\n  // Helper method to format slot date for display\n  formatSlotDateTime: dateTimeString => {\n    try {\n      const date = new Date(dateTimeString);\n      return {\n        date: date.toLocaleDateString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric'\n        }),\n        time: date.toLocaleTimeString('en-US', {\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: true\n        }),\n        full: date.toLocaleString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric',\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: true\n        }),\n        isToday: date.toDateString() === new Date().toDateString(),\n        isTomorrow: date.toDateString() === new Date(Date.now() + 86400000).toDateString(),\n        dayOfWeek: date.toLocaleDateString('en-US', {\n          weekday: 'short'\n        }),\n        shortDate: date.toLocaleDateString('en-US', {\n          month: 'short',\n          day: 'numeric'\n        }),\n        shortTime: date.toLocaleTimeString('en-US', {\n          hour: 'numeric',\n          minute: '2-digit',\n          hour12: true\n        })\n      };\n    } catch (error) {\n      return {\n        date: 'Invalid Date',\n        time: 'Invalid Time',\n        full: 'Invalid Date/Time',\n        isToday: false,\n        isTomorrow: false,\n        dayOfWeek: '---',\n        shortDate: '---',\n        shortTime: '---'\n      };\n    }\n  },\n  // Helper method to check if a slot is bookable\n  isSlotBookable: slotDateTime => {\n    const slotDate = new Date(slotDateTime);\n    const now = new Date();\n    const bufferMinutes = 30;\n    return slotDate > new Date(now.getTime() + bufferMinutes * 60 * 1000);\n  },\n  // Generate slot times based on duration\n  generateSlotTimes: (startTime, endTime, durationMinutes) => {\n    try {\n      const slots = [];\n      const [startHour, startMinute] = startTime.split(':').map(Number);\n      const [endHour, endMinute] = endTime.split(':').map(Number);\n      let currentTime = new Date();\n      currentTime.setHours(startHour, startMinute, 0, 0);\n      const endDateTime = new Date();\n      endDateTime.setHours(endHour, endMinute, 0, 0);\n      while (currentTime < endDateTime) {\n        const nextSlot = new Date(currentTime.getTime() + durationMinutes * 60000);\n        if (nextSlot <= endDateTime) {\n          slots.push({\n            time: currentTime.toTimeString().slice(0, 5),\n            display: currentTime.toLocaleTimeString('en-US', {\n              hour: 'numeric',\n              minute: '2-digit',\n              hour12: true\n            }),\n            value: currentTime.toTimeString()\n          });\n        }\n        currentTime.setTime(currentTime.getTime() + durationMinutes * 60000);\n      }\n      return slots;\n    } catch (error) {\n      return [];\n    }\n  },\n  // Calculate total slots for date range\n  calculateTotalSlots: (startDate, endDate, startTime, endTime, duration, skipWeekends = true) => {\n    try {\n      let totalSlots = 0;\n      const currentDate = new Date(startDate);\n      const finalDate = new Date(endDate);\n      while (currentDate <= finalDate) {\n        if (skipWeekends && (currentDate.getDay() === 0 || currentDate.getDay() === 6)) {\n          currentDate.setDate(currentDate.getDate() + 1);\n          continue;\n        }\n        const daySlots = slotService.generateSlotTimes(startTime, endTime, duration);\n        totalSlots += daySlots.length;\n        currentDate.setDate(currentDate.getDate() + 1);\n      }\n      return totalSlots;\n    } catch (error) {\n      return 0;\n    }\n  },\n  // Method to get slot statistics\n  getSlotStats: async () => {\n    try {\n      const [allSlots, availableSlots] = await Promise.all([slotService.getSlots(), slotService.getAvailableSlots()]);\n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      const tomorrow = new Date(today.getTime() + 86400000);\n      const stats = {\n        total: allSlots.length,\n        available: availableSlots.length,\n        booked: allSlots.filter(slot => slot.IsBooked).length,\n        today: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          return slotDate.toDateString() === today.toDateString();\n        }).length,\n        tomorrow: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          return slotDate.toDateString() === tomorrow.toDateString();\n        }).length,\n        upcoming: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          return slotDate > tomorrow;\n        }).length,\n        thisWeek: availableSlots.filter(slot => {\n          const slotDate = new Date(slot.SlotDateTime);\n          const weekFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);\n          return slotDate <= weekFromNow;\n        }).length,\n        byInterviewer: allSlots.reduce((acc, slot) => {\n          const interviewer = slot.Interviewer || 'Unassigned';\n          acc[interviewer] = (acc[interviewer] || 0) + 1;\n          return acc;\n        }, {})\n      };\n      return stats;\n    } catch (error) {\n      throw error;\n    }\n  },\n  // Get slots by date range\n  getSlotsByDateRange: async (startDate, endDate) => {\n    try {\n      const response = await api.get('/slots/range', {\n        params: {\n          startDate,\n          endDate\n        }\n      });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  // Get slots by interviewer\n  getSlotsByInterviewer: async interviewer => {\n    try {\n      const response = await api.get('/slots/interviewer', {\n        params: {\n          interviewer\n        }\n      });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n};\nexport default slotService;","map":{"version":3,"names":["api","slotService","getSlots","response","get","data","error","getAvailableSlots","createSlot","slotData","slotDateTime","Error","post","createBulkSlots","slotsData","Array","isArray","length","forEach","slot","index","interviewer","date","Date","isNaN","getTime","requestData","slots","timeout","summary","_error$response$data","serverError","code","message","bookSlot","slotId","token","bookingData","parseInt","trim","_error$response$data2","statusCode","status","request","deleteSlot","id","delete","_error$response","_error$response2","_error$response$data3","deleteBulkSlots","slotIds","cancelBooking","reason","_error$response3","_error$response4","_error$response$data4","validateSlotData","slotDate","now","validateBulkSlotData","errors","push","join","formatSlotDateTime","dateTimeString","toLocaleDateString","weekday","year","month","day","time","toLocaleTimeString","hour","minute","hour12","full","toLocaleString","isToday","toDateString","isTomorrow","dayOfWeek","shortDate","shortTime","isSlotBookable","bufferMinutes","generateSlotTimes","startTime","endTime","durationMinutes","startHour","startMinute","split","map","Number","endHour","endMinute","currentTime","setHours","endDateTime","nextSlot","toTimeString","slice","display","value","setTime","calculateTotalSlots","startDate","endDate","duration","skipWeekends","totalSlots","currentDate","finalDate","getDay","setDate","getDate","daySlots","getSlotStats","allSlots","availableSlots","Promise","all","today","getFullYear","getMonth","tomorrow","stats","total","available","booked","filter","IsBooked","SlotDateTime","upcoming","thisWeek","weekFromNow","byInterviewer","reduce","acc","Interviewer","getSlotsByDateRange","params","getSlotsByInterviewer"],"sources":["E:/Downloads/interview-scheduler/interview-scheduler-frontend/src/services/slotService.js"],"sourcesContent":["import api from './api';\r\n\r\nconst slotService = {\r\n    getSlots: async () => {\r\n        try {\r\n            const response = await api.get('/slots');\r\n            return response.data;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    getAvailableSlots: async () => {\r\n        try {\r\n            const response = await api.get('/slots/available');\r\n            return response.data;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    createSlot: async (slotData) => {\r\n        try {\r\n            if (!slotData || !slotData.slotDateTime) {\r\n                throw new Error('Slot date and time are required');\r\n            }\r\n\r\n            const response = await api.post('/slots', slotData);\r\n            return response.data;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // Create multiple slots at once\r\n    createBulkSlots: async (slotsData) => {\r\n        try {\r\n            if (!Array.isArray(slotsData) || slotsData.length === 0) {\r\n                throw new Error('Slots data array is required');\r\n            }\r\n\r\n            // Validate all slots before sending\r\n            slotsData.forEach((slot, index) => {\r\n                if (!slot.slotDateTime) {\r\n                    throw new Error(`Slot ${index + 1}: Date and time are required`);\r\n                }\r\n                if (!slot.interviewer) {\r\n                    throw new Error(`Slot ${index + 1}: Interviewer is required`);\r\n                }\r\n\r\n                // Additional validation\r\n                const date = new Date(slot.slotDateTime);\r\n                if (isNaN(date.getTime())) {\r\n                    throw new Error(`Slot ${index + 1}: Invalid date format - ${slot.slotDateTime}`);\r\n                }\r\n            });\r\n\r\n            const requestData = { slots: slotsData };\r\n\r\n            const response = await api.post('/slots/bulk', requestData, {\r\n                timeout: 30000\r\n            });\r\n\r\n            return response.data.summary;\r\n        } catch (error) {\r\n            if (error.response) {\r\n                const serverError = error.response.data?.error || 'Server error occurred';\r\n                throw new Error(serverError);\r\n            } else if (error.code === 'ECONNABORTED') {\r\n                throw new Error('Request timeout. The bulk operation may still be processing.');\r\n            } else {\r\n                throw new Error(error.message || 'Failed to create bulk slots');\r\n            }\r\n        }\r\n    },\r\n\r\n    bookSlot: async (slotId, token) => {\r\n        try {\r\n            // Validate input parameters\r\n            if (!slotId) {\r\n                throw new Error('Slot ID is required');\r\n            }\r\n            \r\n            if (!token) {\r\n                throw new Error('Authentication token is required');\r\n            }\r\n\r\n            // Ensure slotId is a number and token is a clean string\r\n            const bookingData = {\r\n                slotId: parseInt(slotId), \r\n                token: token.trim()\r\n            };\r\n\r\n            // Validate slotId is a valid number\r\n            if (isNaN(bookingData.slotId)) {\r\n                throw new Error('Invalid slot ID format');\r\n            }\r\n\r\n            const response = await api.post('/slots/book', bookingData);\r\n            return response.data;\r\n        } catch (error) {\r\n            // Enhanced error handling with specific messages\r\n            if (error.response) {\r\n                const serverError = error.response.data?.error || 'Server error occurred';\r\n                const statusCode = error.response.status;\r\n                \r\n                // Handle specific status codes\r\n                switch (statusCode) {\r\n                    case 400:\r\n                        throw new Error(serverError);\r\n                    case 401:\r\n                        throw new Error('Authentication failed. Please check your invitation link.');\r\n                    case 404:\r\n                        throw new Error('Slot not found or invitation token is invalid.');\r\n                    case 409:\r\n                        throw new Error('Slot is no longer available. Please select another slot.');\r\n                    case 500:\r\n                        throw new Error('Server error. Please try again later.');\r\n                    default:\r\n                        throw new Error(serverError);\r\n                }\r\n            } else if (error.request) {\r\n                if (error.code === 'ECONNABORTED') {\r\n                    throw new Error('Request timeout. Please check your connection and try again.');\r\n                }\r\n                throw new Error('Network error. Please check your internet connection.');\r\n            } else {\r\n                throw new Error(error.message || 'An unexpected error occurred while booking the slot.');\r\n            }\r\n        }\r\n    },\r\n\r\n    deleteSlot: async (id) => {\r\n        try {\r\n            if (!id) {\r\n                throw new Error('Slot ID is required');\r\n            }\r\n\r\n            const slotId = parseInt(id);\r\n            if (isNaN(slotId)) {\r\n                throw new Error('Invalid slot ID format');\r\n            }\r\n\r\n            const response = await api.delete(`/slots/${slotId}`);\r\n            return response.data;\r\n        } catch (error) {\r\n            if (error.response?.status === 404) {\r\n                throw new Error('Slot not found');\r\n            } else if (error.response?.status === 400) {\r\n                throw new Error(error.response.data?.error || 'Cannot delete this slot');\r\n            }\r\n            \r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // Bulk delete slots\r\n    deleteBulkSlots: async (slotIds) => {\r\n        try {\r\n            if (!Array.isArray(slotIds) || slotIds.length === 0) {\r\n                throw new Error('Slot IDs array is required');\r\n            }\r\n\r\n            const response = await api.delete('/slots/bulk', {\r\n                data: { slotIds }\r\n            });\r\n\r\n            return response.data;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // Cancel booking\r\n    cancelBooking: async (slotId, reason = 'Cancelled by admin') => {\r\n        try {\r\n            if (!slotId) {\r\n                throw new Error('Slot ID is required');\r\n            }\r\n\r\n            const response = await api.delete(`/slots/${slotId}/cancel`, {\r\n                data: { reason }\r\n            });\r\n\r\n            return response.data;\r\n        } catch (error) {\r\n            if (error.response?.status === 404) {\r\n                throw new Error('Booking not found');\r\n            } else if (error.response?.status === 400) {\r\n                throw new Error(error.response.data?.error || 'Cannot cancel this booking');\r\n            }\r\n            \r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // Helper method to validate slot data\r\n    validateSlotData: (slotData) => {\r\n        if (!slotData) {\r\n            throw new Error('Slot data is required');\r\n        }\r\n\r\n        if (!slotData.slotDateTime) {\r\n            throw new Error('Slot date and time are required');\r\n        }\r\n\r\n        const slotDate = new Date(slotData.slotDateTime);\r\n        const now = new Date();\r\n\r\n        if (isNaN(slotDate.getTime())) {\r\n            throw new Error('Invalid date format');\r\n        }\r\n\r\n        if (slotDate <= now) {\r\n            throw new Error('Slot date must be in the future');\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // Validate bulk slot data\r\n    validateBulkSlotData: (slotsData) => {\r\n        if (!Array.isArray(slotsData) || slotsData.length === 0) {\r\n            throw new Error('Slots data array is required');\r\n        }\r\n\r\n        if (slotsData.length > 500) {\r\n            throw new Error('Cannot create more than 500 slots at once');\r\n        }\r\n\r\n        const errors = [];\r\n        slotsData.forEach((slot, index) => {\r\n            try {\r\n                slotService.validateSlotData(slot);\r\n                \r\n                if (!slot.interviewer) {\r\n                    errors.push(`Slot ${index + 1}: Interviewer is required`);\r\n                }\r\n            } catch (error) {\r\n                errors.push(`Slot ${index + 1}: ${error.message}`);\r\n            }\r\n        });\r\n\r\n        if (errors.length > 0) {\r\n            throw new Error('Validation errors:\\n' + errors.join('\\n'));\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // Helper method to format slot date for display\r\n    formatSlotDateTime: (dateTimeString) => {\r\n        try {\r\n            const date = new Date(dateTimeString);\r\n            return {\r\n                date: date.toLocaleDateString('en-US', {\r\n                    weekday: 'long',\r\n                    year: 'numeric',\r\n                    month: 'long',\r\n                    day: 'numeric'\r\n                }),\r\n                time: date.toLocaleTimeString('en-US', {\r\n                    hour: '2-digit',\r\n                    minute: '2-digit',\r\n                    hour12: true\r\n                }),\r\n                full: date.toLocaleString('en-US', {\r\n                    weekday: 'long',\r\n                    year: 'numeric',\r\n                    month: 'long',\r\n                    day: 'numeric',\r\n                    hour: '2-digit',\r\n                    minute: '2-digit',\r\n                    hour12: true\r\n                }),\r\n                isToday: date.toDateString() === new Date().toDateString(),\r\n                isTomorrow: date.toDateString() === new Date(Date.now() + 86400000).toDateString(),\r\n                dayOfWeek: date.toLocaleDateString('en-US', { weekday: 'short' }),\r\n                shortDate: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),\r\n                shortTime: date.toLocaleTimeString('en-US', { \r\n                    hour: 'numeric', \r\n                    minute: '2-digit',\r\n                    hour12: true \r\n                })\r\n            };\r\n        } catch (error) {\r\n            return {\r\n                date: 'Invalid Date',\r\n                time: 'Invalid Time',\r\n                full: 'Invalid Date/Time',\r\n                isToday: false,\r\n                isTomorrow: false,\r\n                dayOfWeek: '---',\r\n                shortDate: '---',\r\n                shortTime: '---'\r\n            };\r\n        }\r\n    },\r\n\r\n    // Helper method to check if a slot is bookable\r\n    isSlotBookable: (slotDateTime) => {\r\n        const slotDate = new Date(slotDateTime);\r\n        const now = new Date();\r\n        const bufferMinutes = 30;\r\n        \r\n        return slotDate > new Date(now.getTime() + (bufferMinutes * 60 * 1000));\r\n    },\r\n\r\n    // Generate slot times based on duration\r\n    generateSlotTimes: (startTime, endTime, durationMinutes) => {\r\n        try {\r\n            const slots = [];\r\n            \r\n            const [startHour, startMinute] = startTime.split(':').map(Number);\r\n            const [endHour, endMinute] = endTime.split(':').map(Number);\r\n            \r\n            let currentTime = new Date();\r\n            currentTime.setHours(startHour, startMinute, 0, 0);\r\n            \r\n            const endDateTime = new Date();\r\n            endDateTime.setHours(endHour, endMinute, 0, 0);\r\n            \r\n            while (currentTime < endDateTime) {\r\n                const nextSlot = new Date(currentTime.getTime() + (durationMinutes * 60000));\r\n                if (nextSlot <= endDateTime) {\r\n                    slots.push({\r\n                        time: currentTime.toTimeString().slice(0, 5),\r\n                        display: currentTime.toLocaleTimeString('en-US', { \r\n                            hour: 'numeric', \r\n                            minute: '2-digit',\r\n                            hour12: true \r\n                        }),\r\n                        value: currentTime.toTimeString()\r\n                    });\r\n                }\r\n                currentTime.setTime(currentTime.getTime() + (durationMinutes * 60000));\r\n            }\r\n            \r\n            return slots;\r\n        } catch (error) {\r\n            return [];\r\n        }\r\n    },\r\n\r\n    // Calculate total slots for date range\r\n    calculateTotalSlots: (startDate, endDate, startTime, endTime, duration, skipWeekends = true) => {\r\n        try {\r\n            let totalSlots = 0;\r\n            const currentDate = new Date(startDate);\r\n            const finalDate = new Date(endDate);\r\n\r\n            while (currentDate <= finalDate) {\r\n                if (skipWeekends && (currentDate.getDay() === 0 || currentDate.getDay() === 6)) {\r\n                    currentDate.setDate(currentDate.getDate() + 1);\r\n                    continue;\r\n                }\r\n\r\n                const daySlots = slotService.generateSlotTimes(startTime, endTime, duration);\r\n                totalSlots += daySlots.length;\r\n\r\n                currentDate.setDate(currentDate.getDate() + 1);\r\n            }\r\n\r\n            return totalSlots;\r\n        } catch (error) {\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    // Method to get slot statistics\r\n    getSlotStats: async () => {\r\n        try {\r\n            const [allSlots, availableSlots] = await Promise.all([\r\n                slotService.getSlots(),\r\n                slotService.getAvailableSlots()\r\n            ]);\r\n\r\n            const now = new Date();\r\n            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\r\n            const tomorrow = new Date(today.getTime() + 86400000);\r\n\r\n            const stats = {\r\n                total: allSlots.length,\r\n                available: availableSlots.length,\r\n                booked: allSlots.filter(slot => slot.IsBooked).length,\r\n                today: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    return slotDate.toDateString() === today.toDateString();\r\n                }).length,\r\n                tomorrow: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    return slotDate.toDateString() === tomorrow.toDateString();\r\n                }).length,\r\n                upcoming: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    return slotDate > tomorrow;\r\n                }).length,\r\n                thisWeek: availableSlots.filter(slot => {\r\n                    const slotDate = new Date(slot.SlotDateTime);\r\n                    const weekFromNow = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000));\r\n                    return slotDate <= weekFromNow;\r\n                }).length,\r\n                byInterviewer: allSlots.reduce((acc, slot) => {\r\n                    const interviewer = slot.Interviewer || 'Unassigned';\r\n                    acc[interviewer] = (acc[interviewer] || 0) + 1;\r\n                    return acc;\r\n                }, {})\r\n            };\r\n\r\n            return stats;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // Get slots by date range\r\n    getSlotsByDateRange: async (startDate, endDate) => {\r\n        try {\r\n            const response = await api.get('/slots/range', {\r\n                params: { startDate, endDate }\r\n            });\r\n            return response.data;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    // Get slots by interviewer\r\n    getSlotsByInterviewer: async (interviewer) => {\r\n        try {\r\n            const response = await api.get('/slots/interviewer', {\r\n                params: { interviewer }\r\n            });\r\n            return response.data;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n};\r\n\r\nexport default slotService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}